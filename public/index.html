<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Chess 2 ‚Äî Online</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>‚ôö</text></svg>">
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500&display=swap');

  :root {
    --board-light: #ebecd0;
    --board-dark: #739552;
    --board-light-hl: #f6f669;
    --board-dark-hl: #bbcc44;
    --board-light-sel: #f6f669;
    --board-dark-sel: #bbcc44;
    --move-dot: rgba(0,0,0,0.12);
    --capture-ring: rgba(0,0,0,0.12);
    --bg-main: #312e2b;
    --bg-panel: #272522;
    --bg-sidebar: #21201d;
    --bg-card: #2b2926;
    --text-primary: #bababa;
    --text-secondary: #999;
    --text-muted: #666;
    --accent: #81b64c;
    --accent-hover: #96c85e;
    --danger: #e05050;
    --energy-gold: #f0c040;
    --energy-purple: #a060f0;
    --border: #3d3a37;
    --check-red: rgba(255,0,0,0.45);
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg-main);
    color: var(--text-primary);
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
    min-height: 100vh;
    overflow-x: hidden;
  }

  /* ===== LOBBY ===== */
  #lobby {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    gap: 28px;
    padding: 40px 20px;
  }

  .lobby-logo {
    display: flex;
    align-items: center;
    gap: 14px;
    margin-bottom: 8px;
  }
  .lobby-logo .icon {
    width: 56px; height: 56px;
    background: var(--accent);
    border-radius: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 32px;
  }
  .lobby-logo h1 {
    font-size: 2rem;
    font-weight: 800;
    color: #fff;
    letter-spacing: -0.5px;
  }
  .lobby-logo h1 span {
    display: block;
    font-size: 0.8rem;
    font-weight: 400;
    color: var(--text-secondary);
    letter-spacing: 2px;
    text-transform: uppercase;
  }

  .lobby-subtitle {
    color: var(--text-muted);
    font-size: 0.9rem;
    margin-top: -12px;
  }

  .lobby-card {
    background: var(--bg-panel);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 28px 32px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 16px;
    min-width: 340px;
  }
  .lobby-card h2 {
    font-size: 0.85rem;
    font-weight: 600;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  .lobby-btn {
    background: var(--accent);
    color: #fff;
    border: none;
    padding: 14px 0;
    border-radius: 8px;
    cursor: pointer;
    font-family: 'Inter', sans-serif;
    font-size: 1rem;
    font-weight: 700;
    width: 100%;
    transition: all 0.15s;
  }
  .lobby-btn:hover { background: var(--accent-hover); transform: translateY(-1px); }

  .lobby-btn.secondary {
    background: var(--bg-sidebar);
    border: 1px solid var(--border);
    color: var(--text-primary);
  }
  .lobby-btn.secondary:hover {
    border-color: var(--accent);
    color: var(--accent);
    background: rgba(129,182,76,0.08);
  }

  .lobby-btn .btn-icon {
    margin-right: 8px;
    font-size: 1.1em;
  }

  .lobby-divider {
    color: var(--text-muted);
    font-size: 0.8rem;
    display: flex;
    align-items: center;
    gap: 12px;
    width: 100%;
  }
  .lobby-divider::before, .lobby-divider::after {
    content: '';
    flex: 1;
    height: 1px;
    background: var(--border);
  }

  .lobby-row {
    display: flex;
    gap: 8px;
    width: 100%;
  }

  .lobby-input {
    background: var(--bg-sidebar);
    border: 1px solid var(--border);
    color: #fff;
    padding: 12px 16px;
    border-radius: 8px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 1.1rem;
    text-align: center;
    flex: 1;
    letter-spacing: 4px;
    text-transform: uppercase;
  }
  .lobby-input::placeholder { letter-spacing: 1px; text-transform: none; color: var(--text-muted); font-family: 'Inter', sans-serif; font-size: 0.85rem; }
  .lobby-input:focus { outline: none; border-color: var(--accent); }

  .lobby-btn-sm {
    background: var(--bg-sidebar);
    border: 1px solid var(--border);
    color: var(--text-primary);
    padding: 12px 20px;
    border-radius: 8px;
    cursor: pointer;
    font-family: 'Inter', sans-serif;
    font-size: 0.9rem;
    font-weight: 600;
    transition: all 0.15s;
    white-space: nowrap;
  }
  .lobby-btn-sm:hover { border-color: var(--accent); color: var(--accent); }

  #room-link {
    background: var(--bg-sidebar);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 20px 24px;
    text-align: center;
    display: none;
    width: 100%;
  }
  #room-link .label { font-size: 0.7rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1px; }
  #room-link .code {
    font-family: 'JetBrains Mono', monospace;
    font-size: 2.2rem;
    font-weight: 700;
    letter-spacing: 8px;
    color: var(--accent);
    margin: 8px 0;
  }
  #room-link .copy-btn {
    background: var(--bg-card);
    border: 1px solid var(--border);
    color: var(--text-secondary);
    padding: 6px 16px;
    border-radius: 6px;
    cursor: pointer;
    font-family: 'Inter', sans-serif;
    font-size: 0.75rem;
    transition: all 0.15s;
  }
  #room-link .copy-btn:hover { border-color: var(--accent); color: var(--accent); }

  #waiting-msg {
    display: none;
    color: var(--accent);
    font-size: 0.85rem;
    font-weight: 500;
    animation: pulse 1.5s infinite;
  }
  @keyframes pulse { 0%,100%{opacity:0.5} 50%{opacity:1} }

  /* ===== GAME LAYOUT ===== */
  #game-area {
    display: none;
    justify-content: center;
    gap: 16px;
    padding: 16px;
    min-height: 100vh;
    align-items: flex-start;
  }

  /* Board column */
  .board-column {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  /* Player bars */
  .player-bar {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 8px 12px;
    background: var(--bg-panel);
    border-radius: 8px;
    min-height: 48px;
  }
  .player-bar.active {
    background: var(--bg-card);
    box-shadow: inset 3px 0 0 var(--accent);
  }

  .player-avatar {
    width: 36px;
    height: 36px;
    border-radius: 6px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 18px;
    font-weight: 700;
    flex-shrink: 0;
  }
  .player-avatar.white-av { background: #f0d9b5; color: #333; }
  .player-avatar.black-av { background: #333; color: #f0d9b5; border: 1px solid #555; }

  .player-info { flex: 1; min-width: 0; }
  .player-name {
    font-size: 0.85rem;
    font-weight: 600;
    color: #e0e0e0;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .captured-pieces {
    display: flex;
    align-items: center;
    gap: 1px;
    min-height: 20px;
    flex-wrap: wrap;
  }
  .captured-pieces img { width: 18px; height: 18px; opacity: 0.85; }
  .material-diff {
    font-size: 0.7rem;
    font-weight: 600;
    color: var(--text-muted);
    margin-left: 4px;
  }

  .player-energy {
    display: flex;
    align-items: center;
    gap: 4px;
    flex-shrink: 0;
  }
  .energy-pip {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: var(--bg-sidebar);
    border: 1px solid var(--border);
    transition: all 0.3s;
  }
  .energy-pip.filled-w { background: var(--energy-gold); border-color: var(--energy-gold); box-shadow: 0 0 6px var(--energy-gold); }
  .energy-pip.filled-b { background: var(--energy-purple); border-color: var(--energy-purple); box-shadow: 0 0 6px var(--energy-purple); }
  .energy-label { font-size: 0.65rem; color: var(--text-muted); margin-right: 2px; }

  /* Board */
  #board-wrap {
    position: relative;
    line-height: 0;
  }
  canvas#board {
    border-radius: 4px;
    cursor: pointer;
  }

  /* Coordinates overlay */
  .coord-labels {
    position: absolute;
    pointer-events: none;
  }

  /* Sidebar */
  #sidebar {
    display: flex;
    flex-direction: column;
    width: 260px;
    gap: 8px;
  }

  .sidebar-card {
    background: var(--bg-panel);
    border: 1px solid var(--border);
    border-radius: 8px;
    overflow: hidden;
  }

  .sidebar-header {
    padding: 10px 14px;
    font-size: 0.75rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: var(--text-muted);
    border-bottom: 1px solid var(--border);
    background: var(--bg-sidebar);
  }

  /* Move list */
  #move-list {
    max-height: 340px;
    overflow-y: auto;
    scrollbar-width: thin;
    scrollbar-color: var(--border) transparent;
  }
  #move-list::-webkit-scrollbar { width: 4px; }
  #move-list::-webkit-scrollbar-track { background: transparent; }
  #move-list::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

  .move-row {
    display: flex;
    align-items: center;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.8rem;
    border-bottom: 1px solid rgba(255,255,255,0.03);
  }
  .move-row:hover { background: rgba(255,255,255,0.03); }
  .move-num {
    width: 36px;
    text-align: center;
    color: var(--text-muted);
    font-size: 0.7rem;
    flex-shrink: 0;
    padding: 6px 0;
  }
  .move-white, .move-black {
    flex: 1;
    padding: 6px 8px;
    cursor: default;
    color: var(--text-primary);
  }
  .move-white:hover, .move-black:hover { background: rgba(255,255,255,0.05); }
  .move-white.last-move, .move-black.last-move { background: rgba(129,182,76,0.15); color: #fff; }

  /* Status bar */
  #status-bar {
    padding: 10px 14px;
    font-size: 0.8rem;
    color: var(--text-secondary);
    text-align: center;
    background: var(--bg-sidebar);
    border-top: 1px solid var(--border);
  }
  #status-bar.check { color: var(--danger); }
  #status-bar.win { color: var(--accent); }

  /* Action buttons */
  .action-bar {
    display: flex;
    gap: 6px;
    padding: 10px 14px;
  }
  .action-btn {
    flex: 1;
    background: var(--bg-sidebar);
    border: 1px solid var(--border);
    color: var(--text-secondary);
    padding: 8px 12px;
    border-radius: 6px;
    cursor: pointer;
    font-family: 'Inter', sans-serif;
    font-size: 0.75rem;
    font-weight: 600;
    transition: all 0.15s;
    text-align: center;
  }
  .action-btn:hover { border-color: var(--accent); color: var(--accent); }
  .action-btn.active { border-color: var(--energy-gold); color: var(--energy-gold); background: rgba(240,192,64,0.08); }
  .action-btn.primary { background: var(--accent); border-color: var(--accent); color: #fff; }
  .action-btn.primary:hover { background: var(--accent-hover); }

  /* Chess2 info card */
  .chess2-info {
    padding: 12px 14px;
  }
  .chess2-info .mechanic {
    display: flex;
    align-items: flex-start;
    gap: 8px;
    padding: 5px 0;
    font-size: 0.72rem;
    color: var(--text-muted);
    line-height: 1.4;
  }
  .chess2-info .mechanic .icon { font-size: 0.9rem; flex-shrink: 0; width: 18px; text-align: center; }
  .chess2-info .mechanic b { color: var(--text-secondary); }

  /* Promotion overlay */
  #promo-overlay {
    display: none;
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: rgba(0,0,0,0.6);
    align-items: center;
    justify-content: center;
    z-index: 100;
    backdrop-filter: blur(2px);
  }
  #promo-overlay.active { display: flex; }
  #promo-box {
    background: var(--bg-panel);
    border: 2px solid var(--accent);
    border-radius: 12px;
    padding: 16px;
    display: flex;
    gap: 8px;
    box-shadow: 0 20px 60px rgba(0,0,0,0.5);
  }
  .promo-piece {
    width: 64px;
    height: 64px;
    border-radius: 8px;
    border: 2px solid var(--border);
    background: var(--bg-sidebar);
    cursor: pointer;
    transition: all 0.15s;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 8px;
  }
  .promo-piece:hover { border-color: var(--accent); background: var(--bg-card); transform: scale(1.08); }
  .promo-piece img { width: 100%; height: 100%; }

  /* Connection status */
  #connection-status {
    position: fixed;
    top: 10px;
    right: 10px;
    padding: 4px 12px;
    border-radius: 20px;
    font-size: 0.65rem;
    font-weight: 600;
    z-index: 50;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  .connected { background: rgba(129,182,76,0.15); color: var(--accent); border: 1px solid rgba(129,182,76,0.3); }
  .disconnected { background: rgba(224,80,80,0.15); color: var(--danger); border: 1px solid rgba(224,80,80,0.3); }

  /* Thinking indicator */
  #thinking-indicator {
    display: none;
    padding: 8px 14px;
    font-size: 0.8rem;
    color: var(--energy-purple);
    text-align: center;
    animation: pulse 1.2s infinite;
  }

  /* Responsive */
  @media (max-width: 900px) {
    #game-area { flex-direction: column; align-items: center; }
    #sidebar { width: 100%; max-width: 500px; }
  }
</style>
</head>
<body>

<div id="connection-status" class="disconnected">Disconnected</div>

<!-- ===== LOBBY ===== -->
<div id="lobby">
  <div class="lobby-logo">
    <div class="icon">‚ôö</div>
    <h1>Chess 2 <span>Play Online</span></h1>
  </div>
  <p class="lobby-subtitle">New pieces, new mechanics, same competitive spirit</p>

  <div class="lobby-card">
    <button class="lobby-btn" onclick="createBotGame()"><span class="btn-icon">ü§ñ</span> Play vs Computer</button>
    <div class="lobby-divider">or play with a friend</div>
    <button class="lobby-btn secondary" onclick="createRoom()"><span class="btn-icon">üë•</span> Create Room</button>
    <div class="lobby-divider">or join a room</div>
    <div class="lobby-row">
      <input class="lobby-input" id="join-code" placeholder="Room code" maxlength="6">
      <button class="lobby-btn-sm" onclick="joinRoom()">Join</button>
    </div>
  </div>

  <div id="room-link">
    <div class="label">Room Code</div>
    <div class="code" id="room-code-display"></div>
    <button class="copy-btn" onclick="copyLink()">üìã Copy Invite Link</button>
  </div>
  <div id="waiting-msg">Waiting for opponent‚Ä¶</div>
</div>

<!-- ===== GAME ===== -->
<div id="game-area">
  <div class="board-column">
    <div class="player-bar" id="player-top">
      <div class="player-avatar black-av" id="avatar-top">B</div>
      <div class="player-info">
        <div class="player-name" id="name-top">Black</div>
        <div class="captured-pieces" id="captured-top"></div>
      </div>
      <div class="player-energy" id="energy-top"></div>
    </div>

    <div id="board-wrap">
      <canvas id="board" width="640" height="640"></canvas>
    </div>

    <div class="player-bar" id="player-bottom">
      <div class="player-avatar white-av" id="avatar-bottom">W</div>
      <div class="player-info">
        <div class="player-name" id="name-bottom">White</div>
        <div class="captured-pieces" id="captured-bottom"></div>
      </div>
      <div class="player-energy" id="energy-bottom"></div>
    </div>
  </div>

  <div id="sidebar">
    <div class="sidebar-card">
      <div class="sidebar-header">Moves</div>
      <div id="move-list"></div>
      <div id="thinking-indicator">ü§ñ Computer is thinking‚Ä¶</div>
      <div id="status-bar">Waiting for game to start‚Ä¶</div>
    </div>

    <div class="sidebar-card">
      <div class="action-bar">
        <button class="action-btn" id="decree-btn" onclick="sendDecree()">‚ö° Decree</button>
        <button class="action-btn primary" id="newgame-btn" onclick="sendNewGame()" style="display:none;">New Game</button>
      </div>
    </div>

    <div class="sidebar-card">
      <div class="sidebar-header">Chess 2 Mechanics</div>
      <div class="chess2-info">
        <div class="mechanic"><span class="icon">üêâ</span><span><b>Dragon</b> ‚Äî Queen-like, max 3 sq. Can leap 1 piece.</span></div>
        <div class="mechanic"><span class="icon">ü•∑</span><span><b>Shadow</b> ‚Äî Knight + 1-sq diagonal. Right-click to cloak (1‚ö°).</span></div>
        <div class="mechanic"><span class="icon">‚ö°</span><span><b>Energy</b> ‚Äî +1/turn (max 3). Powers abilities.</span></div>
        <div class="mechanic"><span class="icon">üí•</span><span><b>King's Decree</b> (3‚ö°) ‚Äî Push all adjacent enemies outward.</span></div>
        <div class="mechanic"><span class="icon">üéØ</span><span><b>Duels</b> ‚Äî 15% chance both pieces destroyed on capture.</span></div>
        <div class="mechanic"><span class="icon">üè∞</span><span><b>Castling 2.0</b> ‚Äî Can castle with Dragon too.</span></div>
      </div>
    </div>
  </div>
</div>

<!-- Promotion overlay -->
<div id="promo-overlay">
  <div id="promo-box"></div>
</div>

<script>
// ============ CONSTANTS ============
const EMPTY = 0, PAWN = 1, KNIGHT = 2, BISHOP = 3, ROOK = 4, QUEEN = 5, KING = 6, DRAGON = 7, SHADOW = 8;
const WHITE = 1, BLACK = 2;
const PIECE_NAMES = ['','Pawn','Knight','Bishop','Rook','Queen','King','Dragon','Shadow'];
const PIECE_LETTERS = ['','','N','B','R','Q','K','D','S'];
const PIECE_VALUES_SIMPLE = { [PAWN]:1, [KNIGHT]:3, [BISHOP]:3, [ROOK]:5, [QUEEN]:9, [KING]:0, [DRAGON]:7, [SHADOW]:4 };

// ============ PIECE IMAGES (Wikimedia cburnett SVG) ============
const WIKI_BASE = 'https://upload.wikimedia.org/wikipedia/commons';
const PIECE_URLS = {
  [WHITE]: {
    [KING]: `${WIKI_BASE}/4/42/Chess_klt45.svg`,
    [QUEEN]: `${WIKI_BASE}/1/15/Chess_qlt45.svg`,
    [ROOK]: `${WIKI_BASE}/7/72/Chess_rlt45.svg`,
    [BISHOP]: `${WIKI_BASE}/b/b1/Chess_blt45.svg`,
    [KNIGHT]: `${WIKI_BASE}/7/70/Chess_nlt45.svg`,
    [PAWN]: `${WIKI_BASE}/4/45/Chess_plt45.svg`,
  },
  [BLACK]: {
    [KING]: `${WIKI_BASE}/f/f0/Chess_kdt45.svg`,
    [QUEEN]: `${WIKI_BASE}/4/47/Chess_qdt45.svg`,
    [ROOK]: `${WIKI_BASE}/f/ff/Chess_rdt45.svg`,
    [BISHOP]: `${WIKI_BASE}/9/98/Chess_bdt45.svg`,
    [KNIGHT]: `${WIKI_BASE}/e/ef/Chess_ndt45.svg`,
    [PAWN]: `${WIKI_BASE}/c/c7/Chess_pdt45.svg`,
  }
};

// Dragon SVG (inline ‚Äî based on cburnett chancellor/dragon style)
const DRAGON_SVG_WHITE = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45"><g fill="#fff" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M 22.5,11 C 19,11 16,13 14,16 L 10,18 C 8,19 7,21 8,23 L 9,25 C 9,27 11,29 13,29 L 15,29 C 16,31 18,33 21,34 L 24,34 C 27,33 29,31 30,29 L 32,29 C 34,29 36,27 36,25 L 37,23 C 38,21 37,19 35,18 L 31,16 C 29,13 26,11 22.5,11 z"/><path d="M 14,16 L 11,14 L 10,10 L 14,13" fill="#fff" stroke="#000"/><path d="M 31,16 L 34,14 L 35,10 L 31,13" fill="#fff" stroke="#000"/><circle cx="16" cy="20" r="1.5" fill="#000" stroke="none"/><circle cx="29" cy="20" r="1.5" fill="#000" stroke="none"/><path d="M 19,27 L 22.5,30 L 26,27" fill="none" stroke="#000" stroke-width="1"/></g></svg>`;
const DRAGON_SVG_BLACK = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45"><g fill="#333" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M 22.5,11 C 19,11 16,13 14,16 L 10,18 C 8,19 7,21 8,23 L 9,25 C 9,27 11,29 13,29 L 15,29 C 16,31 18,33 21,34 L 24,34 C 27,33 29,31 30,29 L 32,29 C 34,29 36,27 36,25 L 37,23 C 38,21 37,19 35,18 L 31,16 C 29,13 26,11 22.5,11 z" stroke="#fff"/><path d="M 14,16 L 11,14 L 10,10 L 14,13" fill="#333" stroke="#fff"/><path d="M 31,16 L 34,14 L 35,10 L 31,13" fill="#333" stroke="#fff"/><circle cx="16" cy="20" r="1.5" fill="#fff" stroke="none"/><circle cx="29" cy="20" r="1.5" fill="#fff" stroke="none"/><path d="M 19,27 L 22.5,30 L 26,27" fill="none" stroke="#fff" stroke-width="1"/></g></svg>`;

// Shadow SVG (ninja/assassin style)
const SHADOW_SVG_WHITE = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45"><g fill="#fff" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M 22.5,9 C 18,9 15,12 15,15 L 15,17 C 13,18 11,20 11,23 C 11,26 13,28 15,29 L 14,34 L 17,34 L 18,30 L 22.5,31 L 27,30 L 28,34 L 31,34 L 30,29 C 32,28 34,26 34,23 C 34,20 32,18 30,17 L 30,15 C 30,12 27,9 22.5,9 z"/><path d="M 15,19 L 30,19" stroke="#000" stroke-width="2"/><line x1="18" y1="21" x2="20" y2="22" stroke="#000" stroke-width="1"/><line x1="27" y1="21" x2="25" y2="22" stroke="#000" stroke-width="1"/></g></svg>`;
const SHADOW_SVG_BLACK = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45"><g fill="#333" stroke="#fff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M 22.5,9 C 18,9 15,12 15,15 L 15,17 C 13,18 11,20 11,23 C 11,26 13,28 15,29 L 14,34 L 17,34 L 18,30 L 22.5,31 L 27,30 L 28,34 L 31,34 L 30,29 C 32,28 34,26 34,23 C 34,20 32,18 30,17 L 30,15 C 30,12 27,9 22.5,9 z"/><path d="M 15,19 L 30,19" stroke="#fff" stroke-width="2"/><line x1="18" y1="21" x2="20" y2="22" stroke="#fff" stroke-width="1"/><line x1="27" y1="21" x2="25" y2="22" stroke="#fff" stroke-width="1"/></g></svg>`;

// Pre-load images
const pieceImages = {};
let imagesLoaded = 0;
const totalImages = 16; // 6 standard * 2 colors + 2 dragon + 2 shadow

function loadPieceImages(callback) {
  function onLoad() {
    imagesLoaded++;
    if (imagesLoaded >= totalImages && callback) callback();
  }

  for (const color of [WHITE, BLACK]) {
    pieceImages[color] = {};
    for (const type of [KING, QUEEN, ROOK, BISHOP, KNIGHT, PAWN]) {
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.onload = onLoad;
      img.onerror = onLoad;
      img.src = PIECE_URLS[color][type];
      pieceImages[color][type] = img;
    }
    // Dragon
    const dImg = new Image();
    const dSvg = color === WHITE ? DRAGON_SVG_WHITE : DRAGON_SVG_BLACK;
    dImg.onload = onLoad;
    dImg.src = 'data:image/svg+xml;base64,' + btoa(dSvg);
    pieceImages[color][DRAGON] = dImg;

    // Shadow
    const sImg = new Image();
    const sSvg = color === WHITE ? SHADOW_SVG_WHITE : SHADOW_SVG_BLACK;
    sImg.onload = onLoad;
    sImg.src = 'data:image/svg+xml;base64,' + btoa(sSvg);
    pieceImages[color][SHADOW] = sImg;
  }
}

// ============ CANVAS SETUP ============
const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');
const SQ = 80;

// ============ SOUNDS ============
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx;
function ensureAudio() { if (!audioCtx) audioCtx = new AudioCtx(); }

function playSound(type) {
  try {
    ensureAudio();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    gain.gain.value = 0.08;

    if (type === 'move') {
      osc.frequency.value = 600;
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.08);
      osc.start(audioCtx.currentTime);
      osc.stop(audioCtx.currentTime + 0.08);
    } else if (type === 'capture') {
      osc.frequency.value = 300;
      gain.gain.value = 0.12;
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
      osc.start(audioCtx.currentTime);
      osc.stop(audioCtx.currentTime + 0.15);
    } else if (type === 'check') {
      osc.type = 'sawtooth';
      osc.frequency.value = 440;
      gain.gain.value = 0.1;
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.2);
      osc.start(audioCtx.currentTime);
      osc.stop(audioCtx.currentTime + 0.2);
    }
  } catch(e) {}
}

// ============ STATE ============
let ws = null;
let myColor = null;
let roomId = null;
let gameState = null;
let selected = null;
let validMoves = [];
let flipped = false;
let lastMove = null;
let moveHistory = []; // [{num, white, black}]
let prevBoard = null; // for tracking captured pieces
let isBotGame = false;

// Initial piece counts for captured tracking
const INITIAL_PIECES = {
  [WHITE]: { [PAWN]:8, [KNIGHT]:1, [BISHOP]:2, [ROOK]:1, [QUEEN]:1, [KING]:1, [DRAGON]:1, [SHADOW]:1 },
  [BLACK]: { [PAWN]:8, [KNIGHT]:1, [BISHOP]:2, [ROOK]:1, [QUEEN]:1, [KING]:1, [DRAGON]:1, [SHADOW]:1 }
};

// ============ WEBSOCKET ============
function connect() {
  const proto = location.protocol === 'https:' ? 'wss' : 'ws';
  ws = new WebSocket(`${proto}://${location.host}`);

  ws.onopen = () => {
    document.getElementById('connection-status').textContent = 'Connected';
    document.getElementById('connection-status').className = 'connected';
    const params = new URLSearchParams(location.search);
    const code = params.get('room');
    if (code) {
      document.getElementById('join-code').value = code;
      joinRoom();
    }
  };

  ws.onmessage = (e) => {
    const msg = JSON.parse(e.data);
    handleMessage(msg);
  };

  ws.onclose = () => {
    document.getElementById('connection-status').textContent = 'Reconnecting‚Ä¶';
    document.getElementById('connection-status').className = 'disconnected';
    setTimeout(connect, 2000);
  };
}

function handleMessage(msg) {
  switch (msg.type) {
    case 'created':
      roomId = msg.roomId;
      myColor = msg.yourColor;
      document.getElementById('room-code-display').textContent = roomId.toUpperCase();
      document.getElementById('room-link').style.display = 'block';
      document.getElementById('waiting-msg').style.display = 'block';
      history.replaceState(null, '', `?room=${roomId}`);
      break;

    case 'joined':
      roomId = msg.roomId;
      myColor = msg.yourColor;
      history.replaceState(null, '', `?room=${roomId}`);
      showGame();
      break;

    case 'spectating':
      roomId = msg.roomId;
      myColor = null;
      showGame();
      break;

    case 'opponent_joined':
      showGame();
      break;

    case 'opponent_left':
      setStatus('Opponent disconnected ‚Äî they can rejoin.', '');
      break;

    case 'color_swap':
      myColor = msg.yourColor;
      flipped = myColor === BLACK;
      updatePlayerBars();
      break;

    case 'state': {
      const prevState = gameState;
      gameState = msg.state;
      if (msg.yourColor !== undefined && msg.yourColor !== null) {
        myColor = msg.yourColor;
        flipped = myColor === BLACK;
      }

      // Track if this is a bot game
      if (gameState.isBot) isBotGame = true;

      // Detect last move for highlighting
      if (gameState.lastMove) {
        lastMove = gameState.lastMove;
      }

      // Build move history from log
      buildMoveHistory();

      selected = null;
      validMoves = [];
      updateAllUI();
      drawBoard();

      // Sound
      if (prevState) {
        if (gameState.gameOver) playSound('check');
        else if (gameState.log && gameState.log.length > (prevState.log ? prevState.log.length : 0)) {
          const lastLog = gameState.log[gameState.log.length - 1] || '';
          if (lastLog.includes('x') || lastLog.includes('Duel') || lastLog.includes('captures')) playSound('capture');
          else playSound('move');
        }
      }

      // Promotion
      if (gameState.promotionPending && gameState.promotionPending.color === myColor) {
        showPromotionUI(gameState.promotionPending.color);
      } else {
        document.getElementById('promo-overlay').classList.remove('active');
      }

      document.getElementById('newgame-btn').style.display = gameState.gameOver ? 'inline-block' : 'none';

      // Thinking indicator for bot games
      const thinkingEl = document.getElementById('thinking-indicator');
      if (isBotGame && !gameState.gameOver && gameState.turn !== myColor) {
        thinkingEl.style.display = 'block';
      } else {
        thinkingEl.style.display = 'none';
      }

      break;
    }

    case 'legal_moves':
      if (selected && selected.r === msg.r && selected.c === msg.c) {
        validMoves = msg.moves;
        drawBoard();
      }
      break;

    case 'error':
      alert(msg.message);
      break;
  }
}

// ============ LOBBY ============
function createRoom() {
  ws.send(JSON.stringify({ type: 'create' }));
}

function createBotGame() {
  isBotGame = true;
  ws.send(JSON.stringify({ type: 'create_vs_bot' }));
}

function joinRoom() {
  const code = document.getElementById('join-code').value.trim().toLowerCase();
  if (!code) return;
  ws.send(JSON.stringify({ type: 'join', roomId: code }));
}

function copyLink() {
  const url = `${location.origin}?room=${roomId}`;
  navigator.clipboard.writeText(url).then(() => {
    const btn = document.querySelector('.copy-btn');
    btn.textContent = '‚úÖ Copied!';
    setTimeout(() => btn.textContent = 'üìã Copy Invite Link', 2000);
  });
}

function showGame() {
  document.getElementById('lobby').style.display = 'none';
  document.getElementById('game-area').style.display = 'flex';
  flipped = myColor === BLACK;
  updatePlayerBars();
  resizeCanvas();
}

// ============ GAME ACTIONS ============
function sendDecree() {
  if (!gameState || gameState.turn !== myColor || gameState.gameOver) return;
  if (gameState.energy[myColor] < 3) {
    setStatus('Need 3 energy for King\'s Decree!');
    return;
  }
  ws.send(JSON.stringify({ type: 'decree' }));
}

function sendNewGame() {
  ws.send(JSON.stringify({ type: 'new_game' }));
  moveHistory = [];
  lastMove = null;
}

function showPromotionUI(color) {
  const options = [QUEEN, ROOK, BISHOP, KNIGHT, DRAGON];
  const box = document.getElementById('promo-box');
  box.innerHTML = '';
  for (const t of options) {
    const btn = document.createElement('div');
    btn.className = 'promo-piece';
    btn.title = PIECE_NAMES[t];
    const img = document.createElement('img');
    img.src = pieceImages[color][t].src;
    btn.appendChild(img);
    btn.onclick = () => {
      ws.send(JSON.stringify({ type: 'promote', pieceType: t }));
      document.getElementById('promo-overlay').classList.remove('active');
    };
    box.appendChild(btn);
  }
  document.getElementById('promo-overlay').classList.add('active');
}

// ============ BOARD INTERACTION ============
function boardCoords(e) {
  const rect = canvas.getBoundingClientRect();
  const scale = 640 / rect.width;
  const x = (e.clientX - rect.left) * scale;
  const y = (e.clientY - rect.top) * scale;
  let c = Math.floor(x / SQ), r = Math.floor(y / SQ);
  if (flipped) { r = 7 - r; c = 7 - c; }
  return { r, c };
}

canvas.addEventListener('click', (e) => {
  if (!gameState || !myColor || gameState.gameOver) return;
  if (gameState.turn !== myColor) return;
  if (gameState.promotionPending) return;

  const { r, c } = boardCoords(e);
  if (r < 0 || r > 7 || c < 0 || c > 7) return;

  if (selected && validMoves.length) {
    const move = validMoves.find(m => m.r === r && m.c === c);
    if (move) {
      ws.send(JSON.stringify({ type: 'move', fromR: selected.r, fromC: selected.c, toR: r, toC: c }));
      selected = null;
      validMoves = [];
      drawBoard();
      return;
    }
  }

  const board = gameState.board;
  if (board[r][c].color === myColor) {
    selected = { r, c };
    validMoves = [];
    drawBoard();
    ws.send(JSON.stringify({ type: 'get_legal_moves', r, c }));
  } else {
    selected = null;
    validMoves = [];
    drawBoard();
  }
});

canvas.addEventListener('contextmenu', (e) => {
  e.preventDefault();
  if (!gameState || !myColor || gameState.gameOver) return;
  if (gameState.turn !== myColor) return;

  const { r, c } = boardCoords(e);
  if (r < 0 || r > 7 || c < 0 || c > 7) return;

  const board = gameState.board;
  if (board[r][c].type === SHADOW && board[r][c].color === myColor) {
    ws.send(JSON.stringify({ type: 'cloak', r, c }));
  }
});

// ============ DRAWING ============
function drawBoard() {
  if (!gameState) return;
  const board = gameState.board;
  ctx.clearRect(0, 0, 640, 640);

  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      const dr = flipped ? 7 - r : r;
      const dc = flipped ? 7 - c : c;
      const isLight = (dr + dc) % 2 === 0;

      // Last move highlight
      let isLastMove = false;
      if (lastMove) {
        if ((dr === lastMove.fromR && dc === lastMove.fromC) || (dr === lastMove.toR && dc === lastMove.toC)) {
          isLastMove = true;
        }
      }

      // Selected highlight
      let isSelected = false;
      if (selected && selected.r === dr && selected.c === dc) isSelected = true;

      if (isSelected) {
        ctx.fillStyle = isLight ? 'var(--board-light-sel)' : 'var(--board-dark-sel)';
        ctx.fillStyle = isLight ? '#f6f669' : '#bbcc44';
      } else if (isLastMove) {
        ctx.fillStyle = isLight ? '#f6f669' : '#bbcc44';
      } else {
        ctx.fillStyle = isLight ? '#ebecd0' : '#739552';
      }

      ctx.fillRect(c * SQ, r * SQ, SQ, SQ);
    }
  }

  // Check highlight (red glow on king square)
  if (gameState.turn && !gameState.gameOver) {
    for (let r = 0; r < 8; r++) {
      for (let c = 0; c < 8; c++) {
        if (board[r][c].type === KING && board[r][c].color === gameState.turn) {
          // Check if status indicates check
          const statusEl = document.getElementById('status-bar');
          if (statusEl && statusEl.classList.contains('check')) {
            const dr = flipped ? 7 - r : r;
            const dc = flipped ? 7 - c : c;
            const gradient = ctx.createRadialGradient(dc*SQ+SQ/2, dr*SQ+SQ/2, 0, dc*SQ+SQ/2, dr*SQ+SQ/2, SQ*0.7);
            gradient.addColorStop(0, 'rgba(255,0,0,0.55)');
            gradient.addColorStop(1, 'rgba(255,0,0,0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(dc*SQ, dr*SQ, SQ, SQ);
          }
        }
      }
    }
  }

  // Valid move indicators
  for (const m of validMoves) {
    const mr = flipped ? 7 - m.r : m.r;
    const mc = flipped ? 7 - m.c : m.c;
    if (board[m.r][m.c].type !== EMPTY || m.enPassant) {
      // Capture: corner triangles or ring
      ctx.strokeStyle = 'rgba(0,0,0,0.15)';
      ctx.lineWidth = SQ * 0.09;
      ctx.beginPath();
      ctx.arc(mc * SQ + SQ/2, mr * SQ + SQ/2, SQ/2 - 4, 0, Math.PI * 2);
      ctx.stroke();
    } else {
      // Move dot
      ctx.fillStyle = 'rgba(0,0,0,0.14)';
      ctx.beginPath();
      ctx.arc(mc * SQ + SQ/2, mr * SQ + SQ/2, SQ * 0.17, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // Pieces
  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      const p = board[r][c];
      if (p.type === EMPTY) continue;

      const dr = flipped ? 7 - r : r;
      const dc = flipped ? 7 - c : c;

      ctx.save();

      // Cloaked shadow
      const cloakData = gameState.cloaked;
      if (cloakData && cloakData[p.color] && cloakData[p.color].visible &&
          cloakData[p.color].r === r && cloakData[p.color].c === c) {
        ctx.globalAlpha = 0.3;
      }

      const img = pieceImages[p.color] && pieceImages[p.color][p.type];
      if (img && img.complete && img.naturalWidth > 0) {
        const padding = 4;
        ctx.drawImage(img, dc * SQ + padding, dr * SQ + padding, SQ - padding*2, SQ - padding*2);
      } else {
        // Fallback: text
        const PIECE_SYMBOLS = {
          [WHITE]: { [PAWN]:'‚ôô', [KNIGHT]:'‚ôò', [BISHOP]:'‚ôó', [ROOK]:'‚ôñ', [QUEEN]:'‚ôï', [KING]:'‚ôî', [DRAGON]:'üêâ', [SHADOW]:'ü•∑' },
          [BLACK]: { [PAWN]:'‚ôü', [KNIGHT]:'‚ôû', [BISHOP]:'‚ôù', [ROOK]:'‚ôú', [QUEEN]:'‚ôõ', [KING]:'‚ôö', [DRAGON]:'üê≤', [SHADOW]:'üë§' }
        };
        ctx.font = '44px serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = p.color === WHITE ? '#fff' : '#333';
        ctx.fillText(PIECE_SYMBOLS[p.color][p.type] || '?', dc * SQ + SQ/2, dr * SQ + SQ/2 + 2);
      }

      ctx.restore();
    }
  }

  // Coordinate labels
  ctx.font = 'bold 11px Inter, sans-serif';
  for (let i = 0; i < 8; i++) {
    const file = flipped ? 'hgfedcba'[i] : 'abcdefgh'[i];
    const rank = flipped ? (i + 1).toString() : (8 - i).toString();
    const isLight = flipped ? (7 - i + 7) % 2 === 0 : (i + 7) % 2 === 0;
    const isLightR = flipped ? (7 - i) % 2 === 0 : i % 2 === 0;

    // File labels (bottom)
    ctx.fillStyle = isLight ? '#739552' : '#ebecd0';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.fillText(file, i * SQ + SQ - 6, 640 - 3);

    // Rank labels (left)
    ctx.fillStyle = isLightR ? '#739552' : '#ebecd0';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    ctx.fillText(rank, 3, i * SQ + 3);
  }
}

// ============ UI UPDATES ============
function setStatus(msg, cls = '') {
  const bar = document.getElementById('status-bar');
  bar.textContent = msg;
  bar.className = cls || '';
}

function updatePlayerBars() {
  const topIsBlack = !flipped;
  const topColor = topIsBlack ? BLACK : WHITE;
  const botColor = topIsBlack ? WHITE : BLACK;

  // Avatars
  document.getElementById('avatar-top').className = `player-avatar ${topColor === BLACK ? 'black-av' : 'white-av'}`;
  document.getElementById('avatar-top').textContent = topColor === BLACK ? 'B' : 'W';
  document.getElementById('avatar-bottom').className = `player-avatar ${botColor === BLACK ? 'black-av' : 'white-av'}`;
  document.getElementById('avatar-bottom').textContent = botColor === BLACK ? 'B' : 'W';

  // Names
  const opponentLabel = isBotGame ? 'ü§ñ Computer' : null;

  let topName, botName;
  if (topColor === myColor) {
    topName = `${topColor === WHITE ? 'White' : 'Black'} (You)`;
    botName = opponentLabel || (botColor === WHITE ? 'White' : 'Black');
  } else if (botColor === myColor) {
    botName = `${botColor === WHITE ? 'White' : 'Black'} (You)`;
    topName = opponentLabel || (topColor === WHITE ? 'White' : 'Black');
  } else {
    topName = topColor === WHITE ? 'White' : 'Black';
    botName = botColor === WHITE ? 'White' : 'Black';
  }

  document.getElementById('name-top').textContent = topName;
  document.getElementById('name-bottom').textContent = botName;

  if (!gameState) return;

  // Active turn indicator
  const topActive = gameState.turn === topColor && !gameState.gameOver;
  const botActive = gameState.turn === botColor && !gameState.gameOver;
  document.getElementById('player-top').className = `player-bar${topActive ? ' active' : ''}`;
  document.getElementById('player-bottom').className = `player-bar${botActive ? ' active' : ''}`;

  // Energy
  updateEnergyPips('energy-top', topColor);
  updateEnergyPips('energy-bottom', botColor);

  // Captured pieces
  updateCapturedPieces('captured-top', botColor, topColor); // top player captured from bottom's color
  updateCapturedPieces('captured-bottom', topColor, botColor);
}

function updateEnergyPips(elId, color) {
  const el = document.getElementById(elId);
  if (!el || !gameState) return;
  el.innerHTML = '<span class="energy-label">‚ö°</span>';
  for (let i = 0; i < 3; i++) {
    const pip = document.createElement('div');
    pip.className = 'energy-pip' + (i < gameState.energy[color] ? (color === WHITE ? ' filled-w' : ' filled-b') : '');
    el.appendChild(pip);
  }
}

function updateCapturedPieces(elId, capturedFromColor, capturedByColor) {
  const el = document.getElementById(elId);
  if (!el || !gameState) return;
  el.innerHTML = '';

  // Count current pieces on board
  const current = {};
  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      const p = gameState.board[r][c];
      if (p.type !== EMPTY && p.color === capturedFromColor) {
        current[p.type] = (current[p.type] || 0) + 1;
      }
    }
  }

  // Diff from initial
  const initial = INITIAL_PIECES[capturedFromColor];
  const captured = [];
  let materialDiff = 0;

  const order = [QUEEN, DRAGON, ROOK, SHADOW, BISHOP, KNIGHT, PAWN];
  for (const type of order) {
    const diff = (initial[type] || 0) - (current[type] || 0);
    for (let i = 0; i < diff; i++) {
      captured.push(type);
      materialDiff += PIECE_VALUES_SIMPLE[type] || 0;
    }
  }

  for (const type of captured) {
    const img = document.createElement('img');
    img.src = pieceImages[capturedFromColor] && pieceImages[capturedFromColor][type] ? pieceImages[capturedFromColor][type].src : '';
    el.appendChild(img);
  }

  // Material diff
  // Count other side's captured too
  const otherCurrent = {};
  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      const p = gameState.board[r][c];
      if (p.type !== EMPTY && p.color === capturedByColor) {
        otherCurrent[p.type] = (otherCurrent[p.type] || 0) + 1;
      }
    }
  }
  const otherInitial = INITIAL_PIECES[capturedByColor];
  let otherMaterialLost = 0;
  for (const type of order) {
    const diff = (otherInitial[type] || 0) - (otherCurrent[type] || 0);
    otherMaterialLost += diff * (PIECE_VALUES_SIMPLE[type] || 0);
  }

  const netAdvantage = materialDiff - otherMaterialLost;
  if (netAdvantage > 0) {
    const span = document.createElement('span');
    span.className = 'material-diff';
    span.textContent = `+${netAdvantage}`;
    el.appendChild(span);
  }
}

function buildMoveHistory() {
  if (!gameState || !gameState.log) return;
  // Simple: parse log entries into move pairs
  moveHistory = [];
  const logEntries = gameState.log.filter(l => l.includes('‚Üí') || l.includes('castles') || l.includes('Decree') || l.includes('promotes') || l.includes('Duel'));
  let moveNum = 1;
  let current = { num: moveNum, white: '', black: '' };

  for (let i = 0; i < logEntries.length; i++) {
    const entry = logEntries[i];
    const isWhite = entry.startsWith('‚¨ú') || entry.includes('White');

    if (isWhite) {
      current = { num: moveNum, white: cleanMoveText(entry), black: '' };
      moveHistory.push(current);
    } else {
      if (moveHistory.length > 0 && !moveHistory[moveHistory.length-1].black) {
        moveHistory[moveHistory.length-1].black = cleanMoveText(entry);
      } else {
        current = { num: moveNum, white: '...', black: cleanMoveText(entry) };
        moveHistory.push(current);
      }
      moveNum++;
    }
  }
}

function cleanMoveText(entry) {
  return entry.replace(/^[‚¨ú‚¨õ]\s*/, '').replace(/\s+$/, '');
}

function renderMoveList() {
  const el = document.getElementById('move-list');
  el.innerHTML = '';

  for (let i = 0; i < moveHistory.length; i++) {
    const m = moveHistory[i];
    const row = document.createElement('div');
    row.className = 'move-row';

    const num = document.createElement('span');
    num.className = 'move-num';
    num.textContent = m.num + '.';
    row.appendChild(num);

    const wMove = document.createElement('span');
    wMove.className = 'move-white' + (i === moveHistory.length - 1 && !m.black ? ' last-move' : '');
    wMove.textContent = m.white || '';
    row.appendChild(wMove);

    const bMove = document.createElement('span');
    bMove.className = 'move-black' + (i === moveHistory.length - 1 && m.black ? ' last-move' : '');
    bMove.textContent = m.black || '';
    row.appendChild(bMove);

    el.appendChild(row);
  }

  // Scroll to bottom
  el.scrollTop = el.scrollHeight;
}

function updateAllUI() {
  if (!gameState) return;

  updatePlayerBars();
  renderMoveList();

  // Status
  const isMyTurn = gameState.turn === myColor;
  const turnText = gameState.turn === WHITE ? 'White' : 'Black';

  if (gameState.gameOver) {
    if (gameState.winner) {
      const winText = gameState.winner === myColor ? 'You win!' : 'You lose!';
      const colorText = gameState.winner === WHITE ? 'White' : 'Black';
      setStatus(`Checkmate ‚Äî ${colorText} wins! ${myColor ? winText : ''}`, 'win');
    } else {
      setStatus('Stalemate ‚Äî Draw', '');
    }
  } else if (gameState.promotionPending) {
    if (gameState.promotionPending.color === myColor) {
      setStatus('Choose a promotion piece', '');
    } else {
      setStatus('Opponent choosing promotion‚Ä¶', '');
    }
  } else if (isMyTurn) {
    // Check detection from log
    const lastLog = gameState.log && gameState.log.length > 0 ? gameState.log[gameState.log.length - 1] : '';
    if (lastLog.includes('CHECK')) {
      setStatus('You\'re in check!', 'check');
    } else {
      setStatus('Your turn', '');
    }
  } else {
    const lastLog = gameState.log && gameState.log.length > 0 ? gameState.log[gameState.log.length - 1] : '';
    if (isBotGame) {
      if (lastLog.includes('CHECK')) {
        setStatus('Computer is in check', 'check');
      } else {
        setStatus('Computer is thinking‚Ä¶', '');
      }
    } else {
      if (lastLog.includes('CHECK')) {
        setStatus(`${turnText} is in check`, 'check');
      } else {
        setStatus(`${turnText} to move`, '');
      }
    }
  }
}

// ============ RESPONSIVE ============
function resizeCanvas() {
  const maxWidth = Math.min(640, window.innerWidth - 320);
  canvas.style.width = maxWidth + 'px';
  canvas.style.height = maxWidth + 'px';
}
window.addEventListener('resize', resizeCanvas);

// ============ INIT ============
document.getElementById('join-code').addEventListener('keydown', (e) => {
  if (e.key === 'Enter') joinRoom();
});

loadPieceImages(() => {
  if (gameState) drawBoard();
});
connect();
resizeCanvas();
</script>
</body>
</html>
