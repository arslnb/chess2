<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>Chess 2 ‚Äî Online</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>‚ôö</text></svg>">
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500&display=swap');

  :root {
    --board-light: #ebecd0;
    --board-dark: #739552;
    --board-light-hl: #f6f669;
    --board-dark-hl: #bbcc44;
    --move-dot: rgba(0,0,0,0.12);
    --capture-ring: rgba(0,0,0,0.12);
    --bg-main: #312e2b;
    --bg-panel: #272522;
    --bg-sidebar: #21201d;
    --bg-card: #2b2926;
    --text-primary: #bababa;
    --text-secondary: #999;
    --text-muted: #666;
    --accent: #81b64c;
    --accent-hover: #96c85e;
    --danger: #e05050;
    --energy-gold: #f0c040;
    --energy-purple: #a060f0;
    --border: #3d3a37;
    --check-red: rgba(255,0,0,0.45);
    --safe-top: env(safe-area-inset-top, 0px);
    --safe-bottom: env(safe-area-inset-bottom, 0px);
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg-main);
    color: var(--text-primary);
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
    min-height: 100vh;
    min-height: 100dvh;
    overflow-x: hidden;
    -webkit-tap-highlight-color: transparent;
    -webkit-touch-callout: none;
    user-select: none;
    padding-top: var(--safe-top);
    padding-bottom: var(--safe-bottom);
  }

  /* ===== LOBBY ===== */
  #lobby {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    min-height: 100dvh;
    gap: 24px;
    padding: 32px 16px;
  }

  .lobby-logo {
    display: flex;
    align-items: center;
    gap: 14px;
    margin-bottom: 4px;
  }
  .lobby-logo .icon {
    width: 52px; height: 52px;
    background: var(--accent);
    border-radius: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 28px;
  }
  .lobby-logo h1 {
    font-size: 1.8rem;
    font-weight: 800;
    color: #fff;
    letter-spacing: -0.5px;
  }
  .lobby-logo h1 span {
    display: block;
    font-size: 0.75rem;
    font-weight: 400;
    color: var(--text-secondary);
    letter-spacing: 2px;
    text-transform: uppercase;
  }

  .lobby-subtitle {
    color: var(--text-muted);
    font-size: 0.85rem;
    margin-top: -8px;
    text-align: center;
  }

  .lobby-card {
    background: var(--bg-panel);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 24px 28px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 14px;
    width: 100%;
    max-width: 360px;
  }

  .lobby-btn {
    background: var(--accent);
    color: #fff;
    border: none;
    padding: 14px 0;
    border-radius: 8px;
    cursor: pointer;
    font-family: 'Inter', sans-serif;
    font-size: 1rem;
    font-weight: 700;
    width: 100%;
    transition: all 0.15s;
    min-height: 48px;
  }
  .lobby-btn:hover { background: var(--accent-hover); transform: translateY(-1px); }
  .lobby-btn:active { transform: scale(0.98); }

  .lobby-btn.secondary {
    background: var(--bg-sidebar);
    border: 1px solid var(--border);
    color: var(--text-primary);
  }
  .lobby-btn.secondary:hover {
    border-color: var(--accent);
    color: var(--accent);
    background: rgba(129,182,76,0.08);
  }

  .lobby-btn .btn-icon {
    margin-right: 8px;
    font-size: 1.1em;
  }

  .lobby-divider {
    color: var(--text-muted);
    font-size: 0.8rem;
    display: flex;
    align-items: center;
    gap: 12px;
    width: 100%;
  }
  .lobby-divider::before, .lobby-divider::after {
    content: '';
    flex: 1;
    height: 1px;
    background: var(--border);
  }

  .lobby-row {
    display: flex;
    gap: 8px;
    width: 100%;
  }

  .lobby-input {
    background: var(--bg-sidebar);
    border: 1px solid var(--border);
    color: #fff;
    padding: 12px 16px;
    border-radius: 8px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 1.1rem;
    text-align: center;
    flex: 1;
    letter-spacing: 4px;
    text-transform: uppercase;
    min-height: 48px;
  }
  .lobby-input::placeholder { letter-spacing: 1px; text-transform: none; color: var(--text-muted); font-family: 'Inter', sans-serif; font-size: 0.85rem; }
  .lobby-input:focus { outline: none; border-color: var(--accent); }

  .lobby-btn-sm {
    background: var(--bg-sidebar);
    border: 1px solid var(--border);
    color: var(--text-primary);
    padding: 12px 20px;
    border-radius: 8px;
    cursor: pointer;
    font-family: 'Inter', sans-serif;
    font-size: 0.9rem;
    font-weight: 600;
    transition: all 0.15s;
    white-space: nowrap;
    min-height: 48px;
  }
  .lobby-btn-sm:hover { border-color: var(--accent); color: var(--accent); }

  #room-link {
    background: var(--bg-sidebar);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 20px 24px;
    text-align: center;
    display: none;
    width: 100%;
    max-width: 360px;
  }
  #room-link .label { font-size: 0.7rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1px; }
  #room-link .code {
    font-family: 'JetBrains Mono', monospace;
    font-size: 2rem;
    font-weight: 700;
    letter-spacing: 8px;
    color: var(--accent);
    margin: 8px 0;
  }
  #room-link .copy-btn {
    background: var(--bg-card);
    border: 1px solid var(--border);
    color: var(--text-secondary);
    padding: 6px 16px;
    border-radius: 6px;
    cursor: pointer;
    font-family: 'Inter', sans-serif;
    font-size: 0.75rem;
    transition: all 0.15s;
    min-height: 36px;
  }
  #room-link .copy-btn:hover { border-color: var(--accent); color: var(--accent); }

  #waiting-msg {
    display: none;
    color: var(--accent);
    font-size: 0.85rem;
    font-weight: 500;
    animation: pulse 1.5s infinite;
  }
  @keyframes pulse { 0%,100%{opacity:0.5} 50%{opacity:1} }

  /* ===== GAME LAYOUT ===== */
  #game-area {
    display: none;
    justify-content: center;
    gap: 12px;
    padding: 8px;
    min-height: 100vh;
    min-height: 100dvh;
    align-items: flex-start;
  }

  /* Board column */
  .board-column {
    display: flex;
    flex-direction: column;
    gap: 4px;
    max-width: 100%;
  }

  /* Player bars */
  .player-bar {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 6px 10px;
    background: var(--bg-panel);
    border-radius: 8px;
    min-height: 44px;
  }
  .player-bar.active {
    background: var(--bg-card);
    box-shadow: inset 3px 0 0 var(--accent);
  }

  .player-avatar {
    width: 32px;
    height: 32px;
    border-radius: 6px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 16px;
    font-weight: 700;
    flex-shrink: 0;
  }
  .player-avatar.white-av { background: #f0d9b5; color: #333; }
  .player-avatar.black-av { background: #333; color: #f0d9b5; border: 1px solid #555; }

  .player-info { flex: 1; min-width: 0; }
  .player-name {
    font-size: 0.8rem;
    font-weight: 600;
    color: #e0e0e0;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .captured-pieces {
    display: flex;
    align-items: center;
    gap: 1px;
    min-height: 18px;
    flex-wrap: wrap;
  }
  .captured-pieces img { width: 16px; height: 16px; opacity: 0.85; }
  .material-diff {
    font-size: 0.65rem;
    font-weight: 600;
    color: var(--text-muted);
    margin-left: 4px;
  }

  .player-energy {
    display: flex;
    align-items: center;
    gap: 3px;
    flex-shrink: 0;
  }
  .energy-pip {
    width: 9px;
    height: 9px;
    border-radius: 50%;
    background: var(--bg-sidebar);
    border: 1px solid var(--border);
    transition: all 0.3s;
  }
  .energy-pip.filled-w { background: var(--energy-gold); border-color: var(--energy-gold); box-shadow: 0 0 6px var(--energy-gold); }
  .energy-pip.filled-b { background: var(--energy-purple); border-color: var(--energy-purple); box-shadow: 0 0 6px var(--energy-purple); }
  .energy-label { font-size: 0.6rem; color: var(--text-muted); margin-right: 2px; }

  /* Board */
  #board-wrap {
    position: relative;
    line-height: 0;
  }
  canvas#board {
    border-radius: 4px;
    cursor: pointer;
    touch-action: none;
    width: 100%;
    height: auto;
  }

  /* Sidebar */
  #sidebar {
    display: flex;
    flex-direction: column;
    width: 240px;
    gap: 8px;
  }

  .sidebar-card {
    background: var(--bg-panel);
    border: 1px solid var(--border);
    border-radius: 8px;
    overflow: hidden;
  }

  .sidebar-header {
    padding: 8px 12px;
    font-size: 0.7rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: var(--text-muted);
    border-bottom: 1px solid var(--border);
    background: var(--bg-sidebar);
  }

  /* Move list */
  #move-list {
    max-height: 300px;
    overflow-y: auto;
    scrollbar-width: thin;
    scrollbar-color: var(--border) transparent;
  }
  #move-list::-webkit-scrollbar { width: 4px; }
  #move-list::-webkit-scrollbar-track { background: transparent; }
  #move-list::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

  .move-row {
    display: flex;
    align-items: center;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.75rem;
    border-bottom: 1px solid rgba(255,255,255,0.03);
  }
  .move-num {
    width: 32px;
    text-align: center;
    color: var(--text-muted);
    font-size: 0.65rem;
    flex-shrink: 0;
    padding: 5px 0;
  }
  .move-white, .move-black {
    flex: 1;
    padding: 5px 6px;
    color: var(--text-primary);
  }
  .move-white.last-move, .move-black.last-move { background: rgba(129,182,76,0.15); color: #fff; }

  /* Status bar */
  #status-bar {
    padding: 8px 12px;
    font-size: 0.75rem;
    color: var(--text-secondary);
    text-align: center;
    background: var(--bg-sidebar);
    border-top: 1px solid var(--border);
  }
  #status-bar.check { color: var(--danger); }
  #status-bar.win { color: var(--accent); }

  /* Action buttons */
  .action-bar {
    display: flex;
    gap: 6px;
    padding: 8px 10px;
  }
  .action-btn {
    flex: 1;
    background: var(--bg-sidebar);
    border: 1px solid var(--border);
    color: var(--text-secondary);
    padding: 8px 10px;
    border-radius: 6px;
    cursor: pointer;
    font-family: 'Inter', sans-serif;
    font-size: 0.7rem;
    font-weight: 600;
    transition: all 0.15s;
    text-align: center;
    min-height: 40px;
  }
  .action-btn:hover { border-color: var(--accent); color: var(--accent); }
  .action-btn.primary { background: var(--accent); border-color: var(--accent); color: #fff; }
  .action-btn.primary:hover { background: var(--accent-hover); }

  /* Chess2 info card */
  .chess2-info {
    padding: 10px 12px;
  }
  .chess2-info .mechanic {
    display: flex;
    align-items: flex-start;
    gap: 8px;
    padding: 4px 0;
    font-size: 0.68rem;
    color: var(--text-muted);
    line-height: 1.4;
  }
  .chess2-info .mechanic .icon { font-size: 0.85rem; flex-shrink: 0; width: 16px; text-align: center; }
  .chess2-info .mechanic b { color: var(--text-secondary); }

  /* Promotion overlay */
  #promo-overlay {
    display: none;
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: rgba(0,0,0,0.6);
    align-items: center;
    justify-content: center;
    z-index: 100;
    backdrop-filter: blur(2px);
  }
  #promo-overlay.active { display: flex; }
  #promo-box {
    background: var(--bg-panel);
    border: 2px solid var(--accent);
    border-radius: 12px;
    padding: 14px;
    display: flex;
    gap: 8px;
    box-shadow: 0 20px 60px rgba(0,0,0,0.5);
    flex-wrap: wrap;
    justify-content: center;
  }
  .promo-piece {
    width: 56px;
    height: 56px;
    border-radius: 8px;
    border: 2px solid var(--border);
    background: var(--bg-sidebar);
    cursor: pointer;
    transition: all 0.15s;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 6px;
  }
  .promo-piece:hover { border-color: var(--accent); background: var(--bg-card); transform: scale(1.08); }
  .promo-piece img { width: 100%; height: 100%; }

  /* Connection status */
  #connection-status {
    position: fixed;
    top: 8px;
    right: 8px;
    padding: 3px 10px;
    border-radius: 20px;
    font-size: 0.6rem;
    font-weight: 600;
    z-index: 50;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  .connected { background: rgba(129,182,76,0.15); color: var(--accent); border: 1px solid rgba(129,182,76,0.3); }
  .disconnected { background: rgba(224,80,80,0.15); color: var(--danger); border: 1px solid rgba(224,80,80,0.3); }

  /* Thinking indicator */
  #thinking-indicator {
    display: none;
    padding: 6px 10px;
    font-size: 0.75rem;
    color: var(--energy-purple);
    text-align: center;
    animation: pulse 1.2s infinite;
  }

  /* ===== TUTORIAL TOOLTIP ===== */
  #tutorial-overlay {
    display: none;
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: rgba(0,0,0,0.5);
    z-index: 200;
    align-items: center;
    justify-content: center;
    backdrop-filter: blur(2px);
    padding: 16px;
  }
  #tutorial-overlay.active { display: flex; }
  .tutorial-card {
    background: var(--bg-panel);
    border: 2px solid var(--accent);
    border-radius: 14px;
    padding: 24px;
    max-width: 340px;
    width: 100%;
    box-shadow: 0 20px 60px rgba(0,0,0,0.5);
    text-align: center;
    animation: tutorialPop 0.3s ease-out;
  }
  @keyframes tutorialPop {
    0% { transform: scale(0.85); opacity: 0; }
    100% { transform: scale(1); opacity: 1; }
  }
  .tutorial-icon {
    font-size: 3rem;
    margin-bottom: 12px;
  }
  .tutorial-card h3 {
    color: #fff;
    font-size: 1.1rem;
    margin-bottom: 8px;
  }
  .tutorial-card p {
    color: var(--text-secondary);
    font-size: 0.82rem;
    line-height: 1.5;
    margin-bottom: 16px;
  }
  .tutorial-card .moves-hint {
    color: var(--text-muted);
    font-size: 0.72rem;
    line-height: 1.4;
    margin-bottom: 16px;
    padding: 10px;
    background: var(--bg-sidebar);
    border-radius: 8px;
    text-align: left;
  }
  .tutorial-card .moves-hint b { color: var(--text-secondary); }
  .tutorial-btn {
    background: var(--accent);
    color: #fff;
    border: none;
    padding: 10px 32px;
    border-radius: 8px;
    cursor: pointer;
    font-family: 'Inter', sans-serif;
    font-size: 0.85rem;
    font-weight: 700;
    transition: all 0.15s;
    min-height: 44px;
  }
  .tutorial-btn:hover { background: var(--accent-hover); }

  /* ===== DUEL OVERLAY ===== */
  #duel-overlay {
    display: none;
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: rgba(0,0,0,0.7);
    z-index: 150;
    align-items: center;
    justify-content: center;
    backdrop-filter: blur(3px);
    padding: 16px;
  }
  #duel-overlay.active { display: flex; }
  .duel-card {
    background: var(--bg-panel);
    border: 2px solid var(--danger);
    border-radius: 14px;
    padding: 28px 32px;
    max-width: 360px;
    width: 100%;
    box-shadow: 0 0 60px rgba(224,80,80,0.3);
    text-align: center;
    animation: duelShake 0.5s ease-out;
  }
  @keyframes duelShake {
    0% { transform: scale(0.8) rotate(-2deg); opacity: 0; }
    40% { transform: scale(1.05) rotate(1deg); }
    70% { transform: scale(0.98) rotate(-0.5deg); }
    100% { transform: scale(1) rotate(0); opacity: 1; }
  }
  .duel-title {
    font-size: 1.8rem;
    font-weight: 800;
    color: var(--danger);
    margin-bottom: 8px;
    letter-spacing: 2px;
  }
  .duel-pieces {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 16px;
    margin: 16px 0;
  }
  .duel-piece-img {
    width: 64px;
    height: 64px;
    opacity: 0.5;
    filter: grayscale(0.5);
  }
  .duel-vs {
    font-size: 1.5rem;
    font-weight: 800;
    color: var(--danger);
  }
  .duel-subtitle {
    color: var(--text-muted);
    font-size: 0.72rem;
    margin-bottom: 12px;
  }
  .duel-combatant {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
  }
  .duel-label {
    font-size: 0.7rem;
    color: var(--text-secondary);
    font-weight: 600;
  }
  .duel-result-text {
    color: var(--text-secondary);
    font-size: 0.85rem;
    margin-bottom: 16px;
  }
  .duel-first-time-note {
    color: var(--energy-gold);
    font-size: 0.72rem;
    font-style: italic;
    margin-top: 4px;
    padding: 8px 12px;
    background: rgba(240,192,64,0.08);
    border-radius: 6px;
  }
  .attacker-shake {
    animation: shakeLeft 0.6s ease-out;
  }
  .defender-shake {
    animation: shakeRight 0.6s ease-out;
  }
  @keyframes shakeLeft {
    0% { transform: translateX(-30px) rotate(-10deg); opacity: 0; }
    30% { transform: translateX(5px) rotate(2deg); opacity: 1; }
    50% { transform: translateX(-3px); }
    100% { transform: translateX(0) rotate(0); opacity: 0.5; }
  }
  @keyframes shakeRight {
    0% { transform: translateX(30px) rotate(10deg); opacity: 0; }
    30% { transform: translateX(-5px) rotate(-2deg); opacity: 1; }
    50% { transform: translateX(3px); }
    100% { transform: translateX(0) rotate(0); opacity: 0.5; }
  }

  /* ===== LEARN OVERLAY ===== */
  #learn-overlay {
    display: none;
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: rgba(0,0,0,0.7);
    z-index: 250;
    align-items: center;
    justify-content: center;
    backdrop-filter: blur(3px);
    overflow-y: auto;
    padding: 20px;
  }
  #learn-overlay.active { display: flex; }
  .learn-card {
    background: var(--bg-panel);
    border: 2px solid var(--accent);
    border-radius: 14px;
    padding: 24px 28px;
    max-width: 420px;
    width: 100%;
    box-shadow: 0 20px 60px rgba(0,0,0,0.5);
    position: relative;
    max-height: 90vh;
    overflow-y: auto;
    scrollbar-width: thin;
    scrollbar-color: var(--border) transparent;
  }
  .learn-close {
    position: absolute;
    top: 12px; right: 16px;
    font-size: 1.2rem;
    color: var(--text-muted);
    cursor: pointer;
    transition: color 0.15s;
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .learn-close:hover { color: var(--text-primary); }
  .learn-section {
    margin-bottom: 16px;
    padding-bottom: 14px;
    border-bottom: 1px solid var(--border);
  }
  .learn-section:last-of-type { border-bottom: none; }
  .learn-section h3 {
    color: var(--accent);
    font-size: 0.85rem;
    margin-bottom: 6px;
  }
  .learn-section p, .learn-section li {
    color: var(--text-secondary);
    font-size: 0.78rem;
    line-height: 1.5;
  }
  .learn-section ul {
    padding-left: 18px;
    margin-top: 6px;
  }
  .learn-section li { margin-bottom: 3px; }
  .learn-section b { color: var(--text-primary); }
  .learn-piece-row {
    display: flex;
    gap: 12px;
    align-items: flex-start;
    margin-bottom: 12px;
  }
  .learn-piece-icon {
    width: 48px;
    height: 48px;
    flex-shrink: 0;
    border-radius: 8px;
    background: var(--bg-sidebar);
    border: 1px solid var(--border);
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
  }
  .learn-piece-icon img { width: 40px; height: 40px; }
  .learn-piece-row h3 { margin-bottom: 4px; }
  .learn-piece-row p { margin: 0; }

  /* ===== MOBILE RESPONSIVE ===== */
  @media (max-width: 768px) {
    body {
      overflow-y: auto;
    }
    #lobby {
      padding: 20px 12px;
      gap: 16px;
    }
    .lobby-logo h1 { font-size: 1.5rem; }
    .lobby-card { padding: 16px 18px; }
    .lobby-btn { padding: 12px 0; font-size: 0.9rem; }

    #game-area {
      flex-direction: column;
      align-items: center;
      gap: 4px;
      padding: 2px;
      min-height: auto;
    }
    .board-column {
      width: 100%;
      max-width: 100vw;
      gap: 2px;
    }
    #sidebar {
      width: 100%;
      max-width: 100%;
      flex-direction: row;
      flex-wrap: wrap;
      gap: 4px;
      padding: 0 2px 8px;
    }
    #sidebar .sidebar-card {
      flex: 1;
      min-width: 0;
    }
    #sidebar .sidebar-card:first-child {
      flex: 2;
      min-width: 55%;
    }
    #sidebar .sidebar-card:last-child {
      /* Hide mechanics card on mobile ‚Äî save space */
      display: none;
    }
    .player-bar {
      padding: 4px 8px;
      min-height: 38px;
      border-radius: 6px;
      gap: 8px;
    }
    .player-avatar { width: 28px; height: 28px; font-size: 13px; border-radius: 5px; }
    .player-name { font-size: 0.73rem; }
    .captured-pieces img { width: 14px; height: 14px; }
    .energy-pip { width: 8px; height: 8px; }
    .energy-label { font-size: 0.55rem; }
    #move-list { max-height: 100px; }
    .move-row { font-size: 0.68rem; }
    .move-num { width: 28px; font-size: 0.6rem; }
    .sidebar-header { padding: 6px 10px; font-size: 0.65rem; }
    #status-bar { padding: 6px 10px; font-size: 0.7rem; }
    #thinking-indicator { font-size: 0.7rem; padding: 4px 8px; }
    .action-bar { padding: 6px 8px; gap: 4px; }
    .action-btn { padding: 7px 8px; font-size: 0.68rem; border-radius: 5px; min-height: 36px; }
    #connection-status { top: 4px; right: 4px; font-size: 0.5rem; padding: 2px 6px; }

    /* Overlays: fit mobile */
    .tutorial-card { padding: 18px 16px; max-width: 92vw; }
    .tutorial-icon { font-size: 2.4rem; margin-bottom: 8px; }
    .tutorial-card h3 { font-size: 1rem; }
    .tutorial-card p { font-size: 0.78rem; }
    .tutorial-card .moves-hint { font-size: 0.68rem; padding: 8px; }
    .tutorial-btn { padding: 9px 28px; font-size: 0.8rem; }

    .duel-card { padding: 20px 18px; max-width: 85vw; }
    .duel-title { font-size: 1.4rem; }
    .duel-piece-img { width: 48px; height: 48px; }
    .duel-vs { font-size: 1.2rem; }
    .duel-result-text { font-size: 0.78rem; }

    #promo-box { padding: 10px; gap: 6px; }
    .promo-piece { width: 48px; height: 48px; }

    .learn-card { padding: 18px 16px; max-width: 95vw; }
    .learn-piece-icon { width: 40px; height: 40px; }
    .learn-piece-icon img { width: 32px; height: 32px; }
  }

  @media (max-width: 380px) {
    .lobby-logo h1 { font-size: 1.3rem; }
    .lobby-card { padding: 12px 14px; max-width: 100%; }
    .lobby-btn { padding: 10px 0; font-size: 0.85rem; }
    .lobby-input { padding: 10px 12px; font-size: 0.95rem; }
    .promo-piece { width: 42px; height: 42px; }
    .player-bar { padding: 3px 6px; min-height: 34px; }
    .player-avatar { width: 24px; height: 24px; font-size: 11px; }
    .player-name { font-size: 0.68rem; }
  }

  /* Landscape mobile: keep board centered, sidebar collapses to right */
  @media (max-height: 500px) and (orientation: landscape) {
    #game-area {
      flex-direction: row;
      align-items: flex-start;
      gap: 6px;
      padding: 4px;
    }
    .board-column { max-width: 60vw; }
    #sidebar {
      width: 35vw;
      max-height: 100vh;
      overflow-y: auto;
      flex-direction: column;
      flex-wrap: nowrap;
    }
    #sidebar .sidebar-card { min-width: auto; }
    #sidebar .sidebar-card:first-child { min-width: auto; flex: initial; }
  }

  /* Very tall phones (board + sidebar stacked nicely) */
  @media (max-width: 768px) and (min-height: 700px) {
    #move-list { max-height: 150px; }
  }
</style>
</head>
<body>

<div id="connection-status" class="disconnected">Disconnected</div>

<!-- ===== LOBBY ===== -->
<div id="lobby">
  <div class="lobby-logo">
    <div class="icon">‚ôö</div>
    <h1>Chess 2 <span>Play Online</span></h1>
  </div>
  <p class="lobby-subtitle">New pieces, new mechanics, same competitive spirit</p>

  <div class="lobby-card">
    <button class="lobby-btn" onclick="createBotGame()"><span class="btn-icon">ü§ñ</span> Play vs Computer</button>
    <div class="lobby-divider">or play with a friend</div>
    <button class="lobby-btn secondary" onclick="createRoom()"><span class="btn-icon">üë•</span> Create Room</button>
    <div class="lobby-divider">or join a room</div>
    <div class="lobby-row">
      <input class="lobby-input" id="join-code" placeholder="Room code" maxlength="6">
      <button class="lobby-btn-sm" onclick="joinRoom()">Join</button>
    </div>
    <div class="lobby-divider">new to chess 2?</div>
    <button class="lobby-btn secondary" onclick="showLearnOverlay()"><span class="btn-icon">üìñ</span> Learn Chess 2</button>
  </div>

  <div id="room-link">
    <div class="label">Room Code</div>
    <div class="code" id="room-code-display"></div>
    <button class="copy-btn" onclick="copyLink()">üìã Copy Invite Link</button>
  </div>
  <div id="waiting-msg">Waiting for opponent‚Ä¶</div>
</div>

<!-- ===== GAME ===== -->
<div id="game-area">
  <div class="board-column">
    <div class="player-bar" id="player-top">
      <div class="player-avatar black-av" id="avatar-top">B</div>
      <div class="player-info">
        <div class="player-name" id="name-top">Black</div>
        <div class="captured-pieces" id="captured-top"></div>
      </div>
      <div class="player-energy" id="energy-top"></div>
    </div>

    <div id="board-wrap">
      <canvas id="board" width="640" height="640"></canvas>
    </div>

    <div class="player-bar" id="player-bottom">
      <div class="player-avatar white-av" id="avatar-bottom">W</div>
      <div class="player-info">
        <div class="player-name" id="name-bottom">White</div>
        <div class="captured-pieces" id="captured-bottom"></div>
      </div>
      <div class="player-energy" id="energy-bottom"></div>
    </div>
  </div>

  <div id="sidebar">
    <div class="sidebar-card">
      <div class="sidebar-header">Moves</div>
      <div id="move-list"></div>
      <div id="thinking-indicator">ü§ñ Computer is thinking‚Ä¶</div>
      <div id="status-bar">Waiting for game to start‚Ä¶</div>
    </div>

    <div class="sidebar-card">
      <div class="action-bar">
        <button class="action-btn" id="decree-btn" onclick="sendDecree()">‚ö° Decree</button>
        <button class="action-btn" id="learn-btn" onclick="showLearnOverlay()">üìñ Rules</button>
        <button class="action-btn primary" id="newgame-btn" onclick="sendNewGame()" style="display:none;">New Game</button>
      </div>
    </div>

    <div class="sidebar-card">
      <div class="sidebar-header">Chess 2 Mechanics</div>
      <div class="chess2-info">
        <div class="mechanic"><span class="icon">üêâ</span><span><b>Dragon</b> ‚Äî Queen-like, max 3 sq. Can leap 1 piece.</span></div>
        <div class="mechanic"><span class="icon">ü•∑</span><span><b>Shadow</b> ‚Äî Knight + 1-sq diagonal. Right-click to cloak (1‚ö°).</span></div>
        <div class="mechanic"><span class="icon">‚ö°</span><span><b>Energy</b> ‚Äî +1/turn (max 3). Powers abilities.</span></div>
        <div class="mechanic"><span class="icon">üí•</span><span><b>King's Decree</b> (3‚ö°) ‚Äî Push all adjacent enemies outward.</span></div>
        <div class="mechanic"><span class="icon">üéØ</span><span><b>Duels</b> ‚Äî 15% chance both pieces destroyed on capture.</span></div>
        <div class="mechanic"><span class="icon">üè∞</span><span><b>Castling 2.0</b> ‚Äî Can castle with Dragon too.</span></div>
      </div>
    </div>
  </div>
</div>

<!-- Promotion overlay -->
<div id="promo-overlay">
  <div id="promo-box"></div>
</div>

<!-- Tutorial overlay -->
<div id="tutorial-overlay">
  <div class="tutorial-card" id="tutorial-card"></div>
</div>

<!-- Duel overlay -->
<div id="duel-overlay">
  <div class="duel-card" id="duel-card"></div>
</div>

<!-- Learn overlay -->
<div id="learn-overlay">
  <div class="learn-card">
    <div class="learn-close" onclick="closeLearnOverlay()">‚úï</div>
    <h2 style="color:#fff;font-size:1.2rem;margin-bottom:16px;">üìñ Chess 2 ‚Äî What's New?</h2>
    <div class="learn-section">
      <div class="learn-piece-row">
        <div class="learn-piece-icon" id="learn-dragon-icon"></div>
        <div>
          <h3>üêâ Dragon</h3>
          <p>Replaces one Rook. Moves like a Queen but <b>max 3 squares</b>. Can <b>leap over 1 piece</b>. Can castle with the King.</p>
        </div>
      </div>
      <div class="learn-piece-row">
        <div class="learn-piece-icon" id="learn-shadow-icon"></div>
        <div>
          <h3>ü•∑ Shadow</h3>
          <p>Replaces one Knight. Moves like a Knight <b>plus 1 square diagonally</b>. <b>Right-click</b> to cloak for 2 turns (costs 1‚ö°).</p>
        </div>
      </div>
    </div>
    <div class="learn-section">
      <h3>‚ö° Energy System</h3>
      <p>Both players gain <b>+1 energy per turn</b> (max 3). Energy powers abilities:</p>
      <ul>
        <li><b>Cloak Shadow</b> ‚Äî 1‚ö° (invisible for 2 turns)</li>
        <li><b>King's Decree</b> ‚Äî 3‚ö° (push all adjacent enemies outward)</li>
      </ul>
    </div>
    <div class="learn-section">
      <h3>üí• Duels</h3>
      <p>When any piece captures another, there's a <b>15% chance both pieces are destroyed</b>. Kings are immune. High risk, high reward!</p>
    </div>
    <div class="learn-section">
      <h3>üè∞ Castling 2.0</h3>
      <p>You can castle with the Rook (queenside) or the Dragon (kingside), just like normal castling rules.</p>
    </div>
    <div class="learn-section">
      <h3>‚ôü Board Setup</h3>
      <p>Back rank: <b>Rook ¬∑ Shadow ¬∑ Bishop ¬∑ Queen ¬∑ King ¬∑ Bishop ¬∑ Knight ¬∑ Dragon</b><br>Both sides have the same piece order. Each side has exactly <b>one King</b>.</p>
    </div>
    <button class="tutorial-btn" onclick="closeLearnOverlay()" style="margin-top:8px;">Got it ‚Äî Let's Play!</button>
  </div>
</div>

<script>
// ============ CONSTANTS ============
const EMPTY = 0, PAWN = 1, KNIGHT = 2, BISHOP = 3, ROOK = 4, QUEEN = 5, KING = 6, DRAGON = 7, SHADOW = 8;
const WHITE = 1, BLACK = 2;
const PIECE_NAMES = ['','Pawn','Knight','Bishop','Rook','Queen','King','Dragon','Shadow'];
const PIECE_LETTERS = ['','','N','B','R','Q','K','D','S'];
const PIECE_VALUES_SIMPLE = { [PAWN]:1, [KNIGHT]:3, [BISHOP]:3, [ROOK]:5, [QUEEN]:9, [KING]:0, [DRAGON]:7, [SHADOW]:4 };

// ============ PIECE IMAGES (Wikimedia cburnett SVG) ============
const WIKI_BASE = 'https://upload.wikimedia.org/wikipedia/commons';
const PIECE_URLS = {
  [WHITE]: {
    [KING]: `${WIKI_BASE}/4/42/Chess_klt45.svg`,
    [QUEEN]: `${WIKI_BASE}/1/15/Chess_qlt45.svg`,
    [ROOK]: `${WIKI_BASE}/7/72/Chess_rlt45.svg`,
    [BISHOP]: `${WIKI_BASE}/b/b1/Chess_blt45.svg`,
    [KNIGHT]: `${WIKI_BASE}/7/70/Chess_nlt45.svg`,
    [PAWN]: `${WIKI_BASE}/4/45/Chess_plt45.svg`,
  },
  [BLACK]: {
    [KING]: `${WIKI_BASE}/f/f0/Chess_kdt45.svg`,
    [QUEEN]: `${WIKI_BASE}/4/47/Chess_qdt45.svg`,
    [ROOK]: `${WIKI_BASE}/f/ff/Chess_rdt45.svg`,
    [BISHOP]: `${WIKI_BASE}/9/98/Chess_bdt45.svg`,
    [KNIGHT]: `${WIKI_BASE}/e/ef/Chess_ndt45.svg`,
    [PAWN]: `${WIKI_BASE}/c/c7/Chess_pdt45.svg`,
  }
};

// Dragon SVG (inline -- based on cburnett chancellor/dragon style)
const DRAGON_SVG_WHITE = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45"><g fill="#fff" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M 22.5,11 C 19,11 16,13 14,16 L 10,18 C 8,19 7,21 8,23 L 9,25 C 9,27 11,29 13,29 L 15,29 C 16,31 18,33 21,34 L 24,34 C 27,33 29,31 30,29 L 32,29 C 34,29 36,27 36,25 L 37,23 C 38,21 37,19 35,18 L 31,16 C 29,13 26,11 22.5,11 z"/><path d="M 14,16 L 11,14 L 10,10 L 14,13" fill="#fff" stroke="#000"/><path d="M 31,16 L 34,14 L 35,10 L 31,13" fill="#fff" stroke="#000"/><circle cx="16" cy="20" r="1.5" fill="#000" stroke="none"/><circle cx="29" cy="20" r="1.5" fill="#000" stroke="none"/><path d="M 19,27 L 22.5,30 L 26,27" fill="none" stroke="#000" stroke-width="1"/></g></svg>`;
const DRAGON_SVG_BLACK = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45"><g fill="#333" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M 22.5,11 C 19,11 16,13 14,16 L 10,18 C 8,19 7,21 8,23 L 9,25 C 9,27 11,29 13,29 L 15,29 C 16,31 18,33 21,34 L 24,34 C 27,33 29,31 30,29 L 32,29 C 34,29 36,27 36,25 L 37,23 C 38,21 37,19 35,18 L 31,16 C 29,13 26,11 22.5,11 z" stroke="#fff"/><path d="M 14,16 L 11,14 L 10,10 L 14,13" fill="#333" stroke="#fff"/><path d="M 31,16 L 34,14 L 35,10 L 31,13" fill="#333" stroke="#fff"/><circle cx="16" cy="20" r="1.5" fill="#fff" stroke="none"/><circle cx="29" cy="20" r="1.5" fill="#fff" stroke="none"/><path d="M 19,27 L 22.5,30 L 26,27" fill="none" stroke="#fff" stroke-width="1"/></g></svg>`;

// Shadow SVG (ninja/assassin style)
const SHADOW_SVG_WHITE = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45"><g fill="#fff" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M 22.5,9 C 18,9 15,12 15,15 L 15,17 C 13,18 11,20 11,23 C 11,26 13,28 15,29 L 14,34 L 17,34 L 18,30 L 22.5,31 L 27,30 L 28,34 L 31,34 L 30,29 C 32,28 34,26 34,23 C 34,20 32,18 30,17 L 30,15 C 30,12 27,9 22.5,9 z"/><path d="M 15,19 L 30,19" stroke="#000" stroke-width="2"/><line x1="18" y1="21" x2="20" y2="22" stroke="#000" stroke-width="1"/><line x1="27" y1="21" x2="25" y2="22" stroke="#000" stroke-width="1"/></g></svg>`;
const SHADOW_SVG_BLACK = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45"><g fill="#333" stroke="#fff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M 22.5,9 C 18,9 15,12 15,15 L 15,17 C 13,18 11,20 11,23 C 11,26 13,28 15,29 L 14,34 L 17,34 L 18,30 L 22.5,31 L 27,30 L 28,34 L 31,34 L 30,29 C 32,28 34,26 34,23 C 34,20 32,18 30,17 L 30,15 C 30,12 27,9 22.5,9 z"/><path d="M 15,19 L 30,19" stroke="#fff" stroke-width="2"/><line x1="18" y1="21" x2="20" y2="22" stroke="#fff" stroke-width="1"/><line x1="27" y1="21" x2="25" y2="22" stroke="#fff" stroke-width="1"/></g></svg>`;

// Pre-load images
const pieceImages = {};
let imagesLoaded = 0;
const totalImages = 16; // 6 standard * 2 colors + 2 dragon + 2 shadow

function loadPieceImages(callback) {
  function onLoad() {
    imagesLoaded++;
    if (imagesLoaded >= totalImages && callback) callback();
  }

  for (const color of [WHITE, BLACK]) {
    pieceImages[color] = {};
    for (const type of [KING, QUEEN, ROOK, BISHOP, KNIGHT, PAWN]) {
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.onload = onLoad;
      img.onerror = onLoad;
      img.src = PIECE_URLS[color][type];
      pieceImages[color][type] = img;
    }
    // Dragon
    const dImg = new Image();
    const dSvg = color === WHITE ? DRAGON_SVG_WHITE : DRAGON_SVG_BLACK;
    dImg.onload = onLoad;
    dImg.src = 'data:image/svg+xml;base64,' + btoa(dSvg);
    pieceImages[color][DRAGON] = dImg;

    // Shadow
    const sImg = new Image();
    const sSvg = color === WHITE ? SHADOW_SVG_WHITE : SHADOW_SVG_BLACK;
    sImg.onload = onLoad;
    sImg.src = 'data:image/svg+xml;base64,' + btoa(sSvg);
    pieceImages[color][SHADOW] = sImg;
  }
}

// ============ CANVAS SETUP ============
const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');
const SQ = 80;

// ============ SOUNDS ============
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx;
function ensureAudio() { if (!audioCtx) audioCtx = new AudioCtx(); }

function playSound(type) {
  try {
    ensureAudio();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    gain.gain.value = 0.08;

    if (type === 'move') {
      osc.frequency.value = 600;
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.08);
      osc.start(audioCtx.currentTime);
      osc.stop(audioCtx.currentTime + 0.08);
    } else if (type === 'capture') {
      osc.frequency.value = 300;
      gain.gain.value = 0.12;
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
      osc.start(audioCtx.currentTime);
      osc.stop(audioCtx.currentTime + 0.15);
    } else if (type === 'check') {
      osc.type = 'sawtooth';
      osc.frequency.value = 440;
      gain.gain.value = 0.1;
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.2);
      osc.start(audioCtx.currentTime);
      osc.stop(audioCtx.currentTime + 0.2);
    } else if (type === 'duel') {
      osc.type = 'sawtooth';
      osc.frequency.value = 200;
      gain.gain.value = 0.15;
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.4);
      osc.start(audioCtx.currentTime);
      osc.stop(audioCtx.currentTime + 0.4);
    }
  } catch(e) {}
}

// ============ STATE ============
let ws = null;
let myColor = null;
let roomId = null;
let gameState = null;
let selected = null;
let validMoves = [];
let flipped = false;
let lastMove = null;
let moveHistory = [];
let isBotGame = false;

// Initial piece counts (back rank: R S B Q K B N D)
const INITIAL_PIECES = {
  [WHITE]: { [PAWN]:8, [KNIGHT]:1, [BISHOP]:2, [ROOK]:1, [QUEEN]:1, [KING]:1, [DRAGON]:1, [SHADOW]:1 },
  [BLACK]: { [PAWN]:8, [KNIGHT]:1, [BISHOP]:2, [ROOK]:1, [QUEEN]:1, [KING]:1, [DRAGON]:1, [SHADOW]:1 }
};

// ============ TUTORIAL STATE ============
const tutorialSeen = {
  dragon: localStorage.getItem('chess2_tut_dragon') === '1',
  shadow: localStorage.getItem('chess2_tut_shadow') === '1',
  duel: localStorage.getItem('chess2_tut_duel') === '1',
  cloak: localStorage.getItem('chess2_tut_cloak') === '1',
  decree: localStorage.getItem('chess2_tut_decree') === '1',
};

function markTutorialSeen(key) {
  tutorialSeen[key] = true;
  localStorage.setItem('chess2_tut_' + key, '1');
}

function showTutorial(type) {
  if (tutorialSeen[type]) return false;
  
  const tutorials = {
    dragon: {
      icon: 'üêâ',
      title: 'Meet the Dragon!',
      desc: 'A powerful new piece unique to Chess 2! The Dragon replaces one of your rooks.',
      moves: '‚Ä¢ Moves like a Queen, but only up to <b>3 squares</b><br>‚Ä¢ Can <b>leap over 1 piece</b> (friend or foe)<br>‚Ä¢ Can castle with the King just like a Rook<br>‚Ä¢ Worth ~7 points (between Rook and Queen)',
    },
    shadow: {
      icon: 'ü•∑',
      title: 'Meet the Shadow!',
      desc: 'A stealthy assassin that replaces one of your knights. Look for the piece with the shuriken star!',
      moves: '‚Ä¢ Moves like a Knight (L-shape)<br>‚Ä¢ <b>Plus</b> 1 square diagonally<br>‚Ä¢ <b>Right-click</b> to cloak (costs 1‚ö° energy)<br>‚Ä¢ While cloaked, invisible to opponent for 2 turns<br>‚Ä¢ Worth ~4 points',
    },
    duel: {
      icon: '‚öîÔ∏è',
      title: 'Duel ‚Äî Mutual Destruction!',
      desc: 'When a piece captures another, there\'s a 15% chance both pieces are destroyed in combat!',
      moves: 'The attacker and defender both fall ‚Äî a deadly gamble on every capture. <b>Kings are immune</b> to duels. This adds strategic risk to every exchange.',
    },
    decree: {
      icon: 'üëë',
      title: 'King\'s Decree!',
      desc: 'The King commands all adjacent enemies to be pushed back one square!',
      moves: 'Costs <b>3 energy</b>. Pushes all enemy pieces adjacent to your King one square outward. Pieces pushed off the board are removed. Uses your entire turn.',
    },
  };

  const t = tutorials[type];
  if (!t) return false;

  const card = document.getElementById('tutorial-card');
  card.innerHTML = `
    <div class="tutorial-icon">${t.icon}</div>
    <h3>${t.title}</h3>
    <p>${t.desc}</p>
    <div class="moves-hint">${t.moves}</div>
    <button class="tutorial-btn" onclick="closeTutorial('${type}')">Got it!</button>
  `;
  document.getElementById('tutorial-overlay').classList.add('active');
  markTutorialSeen(type);
  return true;
}

function closeTutorial(type) {
  document.getElementById('tutorial-overlay').classList.remove('active');
}

// ============ LEARN OVERLAY ============
function showLearnOverlay() {
  // Populate piece icons in learn overlay
  setTimeout(() => {
    const dragonIcon = document.getElementById('learn-dragon-icon');
    const shadowIcon = document.getElementById('learn-shadow-icon');
    if (dragonIcon && pieceImages[WHITE] && pieceImages[WHITE][DRAGON]) {
      dragonIcon.innerHTML = '';
      const img = document.createElement('img');
      img.src = pieceImages[WHITE][DRAGON].src;
      dragonIcon.appendChild(img);
    }
    if (shadowIcon && pieceImages[WHITE] && pieceImages[WHITE][SHADOW]) {
      shadowIcon.innerHTML = '';
      const img = document.createElement('img');
      img.src = pieceImages[WHITE][SHADOW].src;
      shadowIcon.appendChild(img);
    }
  }, 50);
  document.getElementById('learn-overlay').classList.add('active');
}

function closeLearnOverlay() {
  document.getElementById('learn-overlay').classList.remove('active');
}

// ============ DUEL ANIMATION ============
function showDuelAnimation(duelData) {
  if (!duelData) return;
  
  playSound('duel');
  
  // Determine attacker/defender colors based on who just moved
  const attackerColor = gameState.turn === WHITE ? BLACK : WHITE; // current turn already switched
  const defenderColor = gameState.turn;
  
  const attackerImg = pieceImages[attackerColor]?.[duelData.attacker]?.src || '';
  const defenderImg = pieceImages[defenderColor]?.[duelData.defender]?.src || '';
  
  const isFirstDuel = !tutorialSeen.duel;
  
  const card = document.getElementById('duel-card');
  card.innerHTML = `
    <div class="duel-title">‚öîÔ∏è DUEL! ‚öîÔ∏è</div>
    <div class="duel-subtitle">A 15% chance of mutual destruction ‚Äî and it happened!</div>
    <div class="duel-pieces">
      <div class="duel-combatant">
        <img class="duel-piece-img attacker-shake" src="${attackerImg}" alt="${PIECE_NAMES[duelData.attacker]}">
        <div class="duel-label">${PIECE_NAMES[duelData.attacker]}</div>
      </div>
      <span class="duel-vs">üí•</span>
      <div class="duel-combatant">
        <img class="duel-piece-img defender-shake" src="${defenderImg}" alt="${PIECE_NAMES[duelData.defender]}">
        <div class="duel-label">${PIECE_NAMES[duelData.defender]}</div>
      </div>
    </div>
    <div class="duel-result-text">Both pieces were destroyed in combat!</div>
    ${isFirstDuel ? '<div class="duel-first-time-note">üí° Duels happen 15% of the time when any piece captures. Kings are immune. Plan your captures wisely!</div>' : ''}
  `;
  
  const overlay = document.getElementById('duel-overlay');
  overlay.classList.add('active');
  
  // Auto-dismiss after delay (longer for first duel)
  const delay = isFirstDuel ? 4000 : 2500;
  setTimeout(() => {
    overlay.classList.remove('active');
  }, delay);
  
  if (isFirstDuel) markTutorialSeen('duel');
}

// ============ WEBSOCKET ============
function connect() {
  const proto = location.protocol === 'https:' ? 'wss' : 'ws';
  ws = new WebSocket(`${proto}://${location.host}`);

  ws.onopen = () => {
    document.getElementById('connection-status').textContent = 'Connected';
    document.getElementById('connection-status').className = 'connected';
    const params = new URLSearchParams(location.search);
    const code = params.get('room');
    if (code) {
      document.getElementById('join-code').value = code;
      joinRoom();
    }
  };

  ws.onmessage = (e) => {
    const msg = JSON.parse(e.data);
    handleMessage(msg);
  };

  ws.onclose = () => {
    document.getElementById('connection-status').textContent = 'Reconnecting‚Ä¶';
    document.getElementById('connection-status').className = 'disconnected';
    setTimeout(connect, 2000);
  };
}

function handleMessage(msg) {
  switch (msg.type) {
    case 'created':
      roomId = msg.roomId;
      myColor = msg.yourColor;
      document.getElementById('room-code-display').textContent = roomId.toUpperCase();
      document.getElementById('room-link').style.display = 'block';
      document.getElementById('waiting-msg').style.display = 'block';
      history.replaceState(null, '', `?room=${roomId}`);
      break;

    case 'joined':
      roomId = msg.roomId;
      myColor = msg.yourColor;
      history.replaceState(null, '', `?room=${roomId}`);
      showGame();
      break;

    case 'spectating':
      roomId = msg.roomId;
      myColor = null;
      showGame();
      break;

    case 'opponent_joined':
      showGame();
      break;

    case 'opponent_left':
      setStatus('Opponent disconnected ‚Äî they can rejoin.', '');
      break;

    case 'color_swap':
      myColor = msg.yourColor;
      flipped = myColor === BLACK;
      updatePlayerBars();
      break;

    case 'state': {
      const prevState = gameState;
      gameState = msg.state;
      if (msg.yourColor !== undefined && msg.yourColor !== null) {
        myColor = msg.yourColor;
        flipped = myColor === BLACK;
      }

      if (gameState.isBot) isBotGame = true;

      // Track last move from server info
      if (gameState.lastMoveInfo) {
        lastMove = gameState.lastMoveInfo;
      }

      // Check for duel animation
      if (gameState.lastDuel && prevState) {
        showDuelAnimation(gameState.lastDuel);
      }

      // Check for first-time piece usage tutorials
      if (gameState.lastMoveInfo && prevState) {
        const pt = gameState.lastMoveInfo.pieceType;
        if (pt === DRAGON && !tutorialSeen.dragon) {
          setTimeout(() => showTutorial('dragon'), 300);
        } else if (pt === SHADOW && !tutorialSeen.shadow) {
          setTimeout(() => showTutorial('shadow'), 300);
        }
      }

      buildMoveHistory();

      selected = null;
      validMoves = [];
      updateAllUI();
      drawBoard();

      // Sound
      if (prevState) {
        if (gameState.gameOver) playSound('check');
        else if (gameState.lastDuel) { /* duel sound handled in showDuelAnimation */ }
        else if (gameState.log && gameState.log.length > (prevState.log ? prevState.log.length : 0)) {
          const lastLog = gameState.log[gameState.log.length - 1] || '';
          if (lastLog.includes('x') || lastLog.includes('captures')) playSound('capture');
          else playSound('move');
        }
      }

      // Promotion
      if (gameState.promotionPending && gameState.promotionPending.color === myColor) {
        showPromotionUI(gameState.promotionPending.color);
      } else {
        document.getElementById('promo-overlay').classList.remove('active');
      }

      document.getElementById('newgame-btn').style.display = gameState.gameOver ? 'inline-block' : 'none';

      // Thinking indicator for bot games
      const thinkingEl = document.getElementById('thinking-indicator');
      if (isBotGame && !gameState.gameOver && gameState.turn !== myColor) {
        thinkingEl.style.display = 'block';
      } else {
        thinkingEl.style.display = 'none';
      }

      break;
    }

    case 'legal_moves':
      if (selected && selected.r === msg.r && selected.c === msg.c) {
        validMoves = msg.moves;
        drawBoard();
      }
      break;

    case 'error':
      alert(msg.message);
      break;
  }
}

// ============ LOBBY ============
function createRoom() {
  ws.send(JSON.stringify({ type: 'create' }));
}

function createBotGame() {
  isBotGame = true;
  ws.send(JSON.stringify({ type: 'create_vs_bot' }));
}

function joinRoom() {
  const code = document.getElementById('join-code').value.trim().toLowerCase();
  if (!code) return;
  ws.send(JSON.stringify({ type: 'join', roomId: code }));
}

function copyLink() {
  const url = `${location.origin}?room=${roomId}`;
  navigator.clipboard.writeText(url).then(() => {
    const btn = document.querySelector('.copy-btn');
    btn.textContent = '‚úÖ Copied!';
    setTimeout(() => btn.textContent = 'üìã Copy Invite Link', 2000);
  });
}

function showGame() {
  document.getElementById('lobby').style.display = 'none';
  document.getElementById('game-area').style.display = 'flex';
  flipped = myColor === BLACK;
  updatePlayerBars();
  resizeCanvas();
}

// ============ GAME ACTIONS ============
function sendDecree() {
  if (!gameState || gameState.turn !== myColor || gameState.gameOver) return;
  if (gameState.energy[myColor] < 3) {
    setStatus('Need 3 energy for King\'s Decree!');
    return;
  }
  // Show decree tutorial if first time
  if (!tutorialSeen.decree) {
    showTutorial('decree');
  }
  ws.send(JSON.stringify({ type: 'decree' }));
}

function sendNewGame() {
  ws.send(JSON.stringify({ type: 'new_game' }));
  moveHistory = [];
  lastMove = null;
}

function showPromotionUI(color) {
  const options = [QUEEN, ROOK, BISHOP, KNIGHT, DRAGON];
  const box = document.getElementById('promo-box');
  box.innerHTML = '';
  for (const t of options) {
    const btn = document.createElement('div');
    btn.className = 'promo-piece';
    btn.title = PIECE_NAMES[t];
    const img = document.createElement('img');
    img.src = pieceImages[color][t].src;
    btn.appendChild(img);
    btn.onclick = () => {
      ws.send(JSON.stringify({ type: 'promote', pieceType: t }));
      document.getElementById('promo-overlay').classList.remove('active');
    };
    box.appendChild(btn);
  }
  document.getElementById('promo-overlay').classList.add('active');
}

// ============ BOARD INTERACTION (Drag & Drop + Click) ============
let dragging = null;
let dragThreshold = 5;
let dragStarted = false;
let mouseDownPos = null;

function boardCoords(e) {
  const rect = canvas.getBoundingClientRect();
  const scale = 640 / rect.width;
  const x = (e.clientX - rect.left) * scale;
  const y = (e.clientY - rect.top) * scale;
  let c = Math.floor(x / SQ), r = Math.floor(y / SQ);
  if (flipped) { r = 7 - r; c = 7 - c; }
  return { r, c };
}

function canvasPixelCoords(e) {
  const rect = canvas.getBoundingClientRect();
  const scale = 640 / rect.width;
  return {
    x: (e.clientX - rect.left) * scale,
    y: (e.clientY - rect.top) * scale
  };
}

canvas.addEventListener('mousedown', (e) => {
  if (e.button !== 0) return;
  if (!gameState || !myColor || gameState.gameOver) return;
  if (gameState.turn !== myColor) return;
  if (gameState.promotionPending) return;

  const { r, c } = boardCoords(e);
  if (r < 0 || r > 7 || c < 0 || c > 7) return;

  const px = canvasPixelCoords(e);
  mouseDownPos = { r, c, x: px.x, y: px.y };
  dragStarted = false;

  const board = gameState.board;
  if (board[r][c].color === myColor) {
    dragging = { r, c, piece: board[r][c], curX: px.x, curY: px.y };
    selected = { r, c };
    validMoves = [];
    ws.send(JSON.stringify({ type: 'get_legal_moves', r, c }));
    canvas.style.cursor = 'grabbing';
  }
});

canvas.addEventListener('mousemove', (e) => {
  if (!dragging || !mouseDownPos) return;
  const px = canvasPixelCoords(e);

  if (!dragStarted) {
    const dx = px.x - mouseDownPos.x;
    const dy = px.y - mouseDownPos.y;
    if (Math.sqrt(dx*dx + dy*dy) > dragThreshold) {
      dragStarted = true;
    } else {
      return;
    }
  }

  dragging.curX = px.x;
  dragging.curY = px.y;
  drawBoard();
});

canvas.addEventListener('mouseup', (e) => {
  if (e.button !== 0) return;
  if (!gameState || !myColor || gameState.gameOver) return;

  const { r, c } = boardCoords(e);

  if (dragging && dragStarted) {
    if (r >= 0 && r <= 7 && c >= 0 && c <= 7) {
      const move = validMoves.find(m => m.r === r && m.c === c);
      if (move) {
        ws.send(JSON.stringify({ type: 'move', fromR: dragging.r, fromC: dragging.c, toR: r, toC: c }));
        selected = null;
        validMoves = [];
      } else if (r === dragging.r && c === dragging.c) {
        // keep selected
      } else {
        const board = gameState.board;
        if (board[r][c].color === myColor) {
          selected = { r, c };
          validMoves = [];
          ws.send(JSON.stringify({ type: 'get_legal_moves', r, c }));
        } else {
          selected = null;
          validMoves = [];
        }
      }
    }
    dragging = null;
    dragStarted = false;
    mouseDownPos = null;
    canvas.style.cursor = 'pointer';
    drawBoard();
    return;
  }

  dragging = null;
  dragStarted = false;
  mouseDownPos = null;
  canvas.style.cursor = 'pointer';

  if (gameState.turn !== myColor) return;
  if (gameState.promotionPending) return;
  if (r < 0 || r > 7 || c < 0 || c > 7) return;

  if (selected && validMoves.length) {
    const move = validMoves.find(m => m.r === r && m.c === c);
    if (move) {
      ws.send(JSON.stringify({ type: 'move', fromR: selected.r, fromC: selected.c, toR: r, toC: c }));
      selected = null;
      validMoves = [];
      drawBoard();
      return;
    }
  }

  const board = gameState.board;
  if (board[r][c].color === myColor) {
    selected = { r, c };
    validMoves = [];
    drawBoard();
    ws.send(JSON.stringify({ type: 'get_legal_moves', r, c }));
  } else {
    selected = null;
    validMoves = [];
    drawBoard();
  }
});

canvas.addEventListener('mouseleave', () => {
  if (dragging && dragStarted) {
    dragging = null;
    dragStarted = false;
    mouseDownPos = null;
    canvas.style.cursor = 'pointer';
    drawBoard();
  }
});

canvas.addEventListener('contextmenu', (e) => {
  e.preventDefault();
  if (!gameState || !myColor || gameState.gameOver) return;
  if (gameState.turn !== myColor) return;

  const { r, c } = boardCoords(e);
  if (r < 0 || r > 7 || c < 0 || c > 7) return;

  const board = gameState.board;
  if (board[r][c].type === SHADOW && board[r][c].color === myColor) {
    if (!tutorialSeen.cloak) {
      markTutorialSeen('cloak');
    }
    ws.send(JSON.stringify({ type: 'cloak', r, c }));
  }
});

// ============ TOUCH SUPPORT ============
let touchDragging = null;
let touchDragStarted = false;
let touchStartPos = null;

function touchCoords(touch) {
  const rect = canvas.getBoundingClientRect();
  const scale = 640 / rect.width;
  const x = (touch.clientX - rect.left) * scale;
  const y = (touch.clientY - rect.top) * scale;
  let c = Math.floor(x / SQ), r = Math.floor(y / SQ);
  if (flipped) { r = 7 - r; c = 7 - c; }
  return { r, c, x: (touch.clientX - rect.left) * scale, y: (touch.clientY - rect.top) * scale };
}

canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  if (!gameState || !myColor || gameState.gameOver) return;
  if (gameState.turn !== myColor) return;
  if (gameState.promotionPending) return;

  const touch = e.touches[0];
  const { r, c, x, y } = touchCoords(touch);
  if (r < 0 || r > 7 || c < 0 || c > 7) return;

  touchStartPos = { r, c, x, y };
  touchDragStarted = false;

  const board = gameState.board;
  if (board[r][c].color === myColor) {
    touchDragging = { r, c, piece: board[r][c], curX: x, curY: y };
    selected = { r, c };
    validMoves = [];
    ws.send(JSON.stringify({ type: 'get_legal_moves', r, c }));
  }
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  if (!touchDragging || !touchStartPos) return;
  const touch = e.touches[0];
  const { x, y } = touchCoords(touch);

  if (!touchDragStarted) {
    const dx = x - touchStartPos.x;
    const dy = y - touchStartPos.y;
    if (Math.sqrt(dx*dx + dy*dy) > dragThreshold) {
      touchDragStarted = true;
    } else {
      return;
    }
  }

  touchDragging.curX = x;
  touchDragging.curY = y;
  dragging = touchDragging;
  dragStarted = true;
  drawBoard();
}, { passive: false });

canvas.addEventListener('touchend', (e) => {
  e.preventDefault();
  if (!touchDragging) {
    // Tap without owning piece: try click-to-move
    if (touchStartPos && selected && validMoves.length) {
      const { r, c } = touchStartPos;
      const move = validMoves.find(m => m.r === r && m.c === c);
      if (move) {
        ws.send(JSON.stringify({ type: 'move', fromR: selected.r, fromC: selected.c, toR: r, toC: c }));
        selected = null;
        validMoves = [];
        drawBoard();
      }
    }
    touchStartPos = null;
    return;
  }

  if (touchDragStarted && e.changedTouches.length > 0) {
    const touch = e.changedTouches[0];
    const { r, c } = touchCoords(touch);
    if (r >= 0 && r <= 7 && c >= 0 && c <= 7) {
      const move = validMoves.find(m => m.r === r && m.c === c);
      if (move) {
        ws.send(JSON.stringify({ type: 'move', fromR: touchDragging.r, fromC: touchDragging.c, toR: r, toC: c }));
        selected = null;
        validMoves = [];
      }
    }
  } else {
    // Tap (no drag): click-to-select / click-to-move
    if (touchStartPos) {
      const { r, c } = touchStartPos;
      if (selected && validMoves.length) {
        const move = validMoves.find(m => m.r === r && m.c === c);
        if (move) {
          ws.send(JSON.stringify({ type: 'move', fromR: selected.r, fromC: selected.c, toR: r, toC: c }));
          selected = null;
          validMoves = [];
        } else if (gameState.board[r][c].color === myColor) {
          selected = { r, c };
          validMoves = [];
          ws.send(JSON.stringify({ type: 'get_legal_moves', r, c }));
        } else {
          selected = null;
          validMoves = [];
        }
      }
    }
  }

  touchDragging = null;
  touchDragStarted = false;
  touchStartPos = null;
  dragging = null;
  dragStarted = false;
  drawBoard();
}, { passive: false });

// Long-press for cloak on mobile
let longPressTimer = null;
canvas.addEventListener('touchstart', (e) => {
  const touch = e.touches[0];
  const { r, c } = touchCoords(touch);
  if (r < 0 || r > 7 || c < 0 || c > 7) return;
  if (!gameState || !myColor || gameState.gameOver || gameState.turn !== myColor) return;
  
  const board = gameState.board;
  if (board[r][c].type === SHADOW && board[r][c].color === myColor) {
    longPressTimer = setTimeout(() => {
      if (!tutorialSeen.cloak) markTutorialSeen('cloak');
      ws.send(JSON.stringify({ type: 'cloak', r, c }));
      // Cancel any drag
      touchDragging = null;
      touchDragStarted = false;
      touchStartPos = null;
      dragging = null;
      dragStarted = false;
    }, 500);
  }
}, { passive: true });

canvas.addEventListener('touchmove', () => {
  if (longPressTimer) { clearTimeout(longPressTimer); longPressTimer = null; }
}, { passive: true });

canvas.addEventListener('touchend', () => {
  if (longPressTimer) { clearTimeout(longPressTimer); longPressTimer = null; }
}, { passive: true });

// ============ DRAWING ============
function drawBoard() {
  if (!gameState) return;
  const board = gameState.board;
  ctx.clearRect(0, 0, 640, 640);

  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      const dr = flipped ? 7 - r : r;
      const dc = flipped ? 7 - c : c;
      const isLight = (dr + dc) % 2 === 0;

      let isLastMove = false;
      if (lastMove) {
        if ((dr === lastMove.fromR && dc === lastMove.fromC) || (dr === lastMove.toR && dc === lastMove.toC)) {
          isLastMove = true;
        }
      }

      let isSelected = false;
      if (selected && selected.r === dr && selected.c === dc) isSelected = true;

      if (isSelected || isLastMove) {
        ctx.fillStyle = isLight ? '#f6f669' : '#bbcc44';
      } else {
        ctx.fillStyle = isLight ? '#ebecd0' : '#739552';
      }

      ctx.fillRect(c * SQ, r * SQ, SQ, SQ);
    }
  }

  // Check highlight
  if (gameState.turn && !gameState.gameOver) {
    for (let r = 0; r < 8; r++) {
      for (let c = 0; c < 8; c++) {
        if (board[r][c].type === KING && board[r][c].color === gameState.turn) {
          const statusEl = document.getElementById('status-bar');
          if (statusEl && statusEl.classList.contains('check')) {
            const dr = flipped ? 7 - r : r;
            const dc = flipped ? 7 - c : c;
            const gradient = ctx.createRadialGradient(dc*SQ+SQ/2, dr*SQ+SQ/2, 0, dc*SQ+SQ/2, dr*SQ+SQ/2, SQ*0.7);
            gradient.addColorStop(0, 'rgba(255,0,0,0.55)');
            gradient.addColorStop(1, 'rgba(255,0,0,0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(dc*SQ, dr*SQ, SQ, SQ);
          }
        }
      }
    }
  }

  // Drag hover highlight
  if (dragging && dragStarted) {
    let hoverC = Math.floor(dragging.curX / SQ);
    let hoverR = Math.floor(dragging.curY / SQ);
    if (flipped) { hoverR = 7 - hoverR; hoverC = 7 - hoverC; }
    const isHoverValid = validMoves.some(m => m.r === hoverR && m.c === hoverC);
    if (isHoverValid && hoverR >= 0 && hoverR <= 7 && hoverC >= 0 && hoverC <= 7) {
      const dhR = flipped ? 7 - hoverR : hoverR;
      const dhC = flipped ? 7 - hoverC : hoverC;
      ctx.fillStyle = 'rgba(129,182,76,0.35)';
      ctx.fillRect(dhC * SQ, dhR * SQ, SQ, SQ);
    }
  }

  // Valid move indicators
  for (const m of validMoves) {
    const mr = flipped ? 7 - m.r : m.r;
    const mc = flipped ? 7 - m.c : m.c;
    if (board[m.r][m.c].type !== EMPTY || m.enPassant) {
      ctx.strokeStyle = 'rgba(0,0,0,0.15)';
      ctx.lineWidth = SQ * 0.09;
      ctx.beginPath();
      ctx.arc(mc * SQ + SQ/2, mr * SQ + SQ/2, SQ/2 - 4, 0, Math.PI * 2);
      ctx.stroke();
    } else {
      ctx.fillStyle = 'rgba(0,0,0,0.14)';
      ctx.beginPath();
      ctx.arc(mc * SQ + SQ/2, mr * SQ + SQ/2, SQ * 0.17, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // Pieces
  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      const p = board[r][c];
      if (p.type === EMPTY) continue;

      const isDragSource = dragging && dragStarted && dragging.r === r && dragging.c === c;
      const dr = flipped ? 7 - r : r;
      const dc = flipped ? 7 - c : c;

      ctx.save();

      const cloakData = gameState.cloaked;
      if (cloakData && cloakData[p.color] && cloakData[p.color].visible &&
          cloakData[p.color].r === r && cloakData[p.color].c === c) {
        ctx.globalAlpha = 0.3;
      }

      if (isDragSource) {
        ctx.globalAlpha = 0.25;
      }

      const img = pieceImages[p.color] && pieceImages[p.color][p.type];
      if (img && img.complete && img.naturalWidth > 0) {
        const padding = 4;
        ctx.drawImage(img, dc * SQ + padding, dr * SQ + padding, SQ - padding*2, SQ - padding*2);
      } else {
        const PIECE_SYMBOLS = {
          [WHITE]: { [PAWN]:'‚ôô', [KNIGHT]:'‚ôò', [BISHOP]:'‚ôó', [ROOK]:'‚ôñ', [QUEEN]:'‚ôï', [KING]:'‚ôî', [DRAGON]:'D', [SHADOW]:'S' },
          [BLACK]: { [PAWN]:'‚ôü', [KNIGHT]:'‚ôû', [BISHOP]:'‚ôù', [ROOK]:'‚ôú', [QUEEN]:'‚ôõ', [KING]:'‚ôö', [DRAGON]:'D', [SHADOW]:'S' }
        };
        ctx.font = 'bold 40px Inter, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = p.color === WHITE ? '#fff' : '#333';
        ctx.strokeStyle = p.color === WHITE ? '#000' : '#fff';
        ctx.lineWidth = 1;
        const sym = PIECE_SYMBOLS[p.color][p.type] || '?';
        ctx.fillText(sym, dc * SQ + SQ/2, dr * SQ + SQ/2 + 2);
        if (p.type === DRAGON || p.type === SHADOW) {
          ctx.strokeText(sym, dc * SQ + SQ/2, dr * SQ + SQ/2 + 2);
        }
      }

      ctx.restore();
    }
  }

  // Dragged piece
  if (dragging && dragStarted && dragging.piece) {
    ctx.save();
    const img = pieceImages[dragging.piece.color] && pieceImages[dragging.piece.color][dragging.piece.type];
    const size = SQ * 1.1;
    const halfSize = size / 2;

    ctx.shadowColor = 'rgba(0,0,0,0.4)';
    ctx.shadowBlur = 12;
    ctx.shadowOffsetX = 3;
    ctx.shadowOffsetY = 6;

    if (img && img.complete && img.naturalWidth > 0) {
      ctx.drawImage(img, dragging.curX - halfSize, dragging.curY - halfSize, size, size);
    } else {
      ctx.font = 'bold 48px Inter, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = dragging.piece.color === WHITE ? '#fff' : '#333';
      ctx.fillText('?', dragging.curX, dragging.curY);
    }
    ctx.restore();
  }

  // Coordinate labels
  ctx.font = 'bold 11px Inter, sans-serif';
  for (let i = 0; i < 8; i++) {
    const file = flipped ? 'hgfedcba'[i] : 'abcdefgh'[i];
    const rank = flipped ? (i + 1).toString() : (8 - i).toString();
    const isLight = flipped ? (7 - i + 7) % 2 === 0 : (i + 7) % 2 === 0;
    const isLightR = flipped ? (7 - i) % 2 === 0 : i % 2 === 0;

    ctx.fillStyle = isLight ? '#739552' : '#ebecd0';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.fillText(file, i * SQ + SQ - 6, 640 - 3);

    ctx.fillStyle = isLightR ? '#739552' : '#ebecd0';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    ctx.fillText(rank, 3, i * SQ + 3);
  }
}

// ============ UI UPDATES ============
function setStatus(msg, cls = '') {
  const bar = document.getElementById('status-bar');
  bar.textContent = msg;
  bar.className = cls || '';
}

function updatePlayerBars() {
  const topIsBlack = !flipped;
  const topColor = topIsBlack ? BLACK : WHITE;
  const botColor = topIsBlack ? WHITE : BLACK;

  document.getElementById('avatar-top').className = `player-avatar ${topColor === BLACK ? 'black-av' : 'white-av'}`;
  document.getElementById('avatar-top').textContent = topColor === BLACK ? 'B' : 'W';
  document.getElementById('avatar-bottom').className = `player-avatar ${botColor === BLACK ? 'black-av' : 'white-av'}`;
  document.getElementById('avatar-bottom').textContent = botColor === BLACK ? 'B' : 'W';

  const opponentLabel = isBotGame ? 'ü§ñ Computer' : null;

  let topName, botName;
  if (topColor === myColor) {
    topName = `${topColor === WHITE ? 'White' : 'Black'} (You)`;
    botName = opponentLabel || (botColor === WHITE ? 'White' : 'Black');
  } else if (botColor === myColor) {
    botName = `${botColor === WHITE ? 'White' : 'Black'} (You)`;
    topName = opponentLabel || (topColor === WHITE ? 'White' : 'Black');
  } else {
    topName = topColor === WHITE ? 'White' : 'Black';
    botName = botColor === WHITE ? 'White' : 'Black';
  }

  document.getElementById('name-top').textContent = topName;
  document.getElementById('name-bottom').textContent = botName;

  if (!gameState) return;

  const topActive = gameState.turn === topColor && !gameState.gameOver;
  const botActive = gameState.turn === botColor && !gameState.gameOver;
  document.getElementById('player-top').className = `player-bar${topActive ? ' active' : ''}`;
  document.getElementById('player-bottom').className = `player-bar${botActive ? ' active' : ''}`;

  updateEnergyPips('energy-top', topColor);
  updateEnergyPips('energy-bottom', botColor);

  updateCapturedPieces('captured-top', botColor, topColor);
  updateCapturedPieces('captured-bottom', topColor, botColor);
}

function updateEnergyPips(elId, color) {
  const el = document.getElementById(elId);
  if (!el || !gameState) return;
  el.innerHTML = '<span class="energy-label">‚ö°</span>';
  for (let i = 0; i < 3; i++) {
    const pip = document.createElement('div');
    pip.className = 'energy-pip' + (i < gameState.energy[color] ? (color === WHITE ? ' filled-w' : ' filled-b') : '');
    el.appendChild(pip);
  }
}

function updateCapturedPieces(elId, capturedFromColor, capturedByColor) {
  const el = document.getElementById(elId);
  if (!el || !gameState) return;
  el.innerHTML = '';

  const current = {};
  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      const p = gameState.board[r][c];
      if (p.type !== EMPTY && p.color === capturedFromColor) {
        current[p.type] = (current[p.type] || 0) + 1;
      }
    }
  }

  const initial = INITIAL_PIECES[capturedFromColor];
  const captured = [];
  let materialDiff = 0;

  const order = [QUEEN, DRAGON, ROOK, SHADOW, BISHOP, KNIGHT, PAWN];
  for (const type of order) {
    const diff = (initial[type] || 0) - (current[type] || 0);
    for (let i = 0; i < diff; i++) {
      captured.push(type);
      materialDiff += PIECE_VALUES_SIMPLE[type] || 0;
    }
  }

  for (const type of captured) {
    const img = document.createElement('img');
    img.src = pieceImages[capturedFromColor]?.[type]?.src || '';
    el.appendChild(img);
  }

  const otherCurrent = {};
  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      const p = gameState.board[r][c];
      if (p.type !== EMPTY && p.color === capturedByColor) {
        otherCurrent[p.type] = (otherCurrent[p.type] || 0) + 1;
      }
    }
  }
  const otherInitial = INITIAL_PIECES[capturedByColor];
  let otherMaterialLost = 0;
  for (const type of order) {
    const diff = (otherInitial[type] || 0) - (otherCurrent[type] || 0);
    otherMaterialLost += diff * (PIECE_VALUES_SIMPLE[type] || 0);
  }

  const netAdvantage = materialDiff - otherMaterialLost;
  if (netAdvantage > 0) {
    const span = document.createElement('span');
    span.className = 'material-diff';
    span.textContent = `+${netAdvantage}`;
    el.appendChild(span);
  }
}

function buildMoveHistory() {
  if (!gameState || !gameState.log) return;
  moveHistory = [];
  const logEntries = gameState.log.filter(l => l.includes('‚Üí') || l.includes('castles') || l.includes('Decree') || l.includes('promotes') || l.includes('Duel'));
  let moveNum = 1;
  let current = { num: moveNum, white: '', black: '' };

  for (let i = 0; i < logEntries.length; i++) {
    const entry = logEntries[i];
    const isWhite = entry.startsWith('‚¨ú') || entry.includes('White');

    if (isWhite) {
      current = { num: moveNum, white: cleanMoveText(entry), black: '' };
      moveHistory.push(current);
    } else {
      if (moveHistory.length > 0 && !moveHistory[moveHistory.length-1].black) {
        moveHistory[moveHistory.length-1].black = cleanMoveText(entry);
      } else {
        current = { num: moveNum, white: '...', black: cleanMoveText(entry) };
        moveHistory.push(current);
      }
      moveNum++;
    }
  }
}

function cleanMoveText(entry) {
  return entry.replace(/^[‚¨ú‚¨õ]\s*/, '').replace(/\s+$/, '');
}

function renderMoveList() {
  const el = document.getElementById('move-list');
  el.innerHTML = '';

  for (let i = 0; i < moveHistory.length; i++) {
    const m = moveHistory[i];
    const row = document.createElement('div');
    row.className = 'move-row';

    const num = document.createElement('span');
    num.className = 'move-num';
    num.textContent = m.num + '.';
    row.appendChild(num);

    const wMove = document.createElement('span');
    wMove.className = 'move-white' + (i === moveHistory.length - 1 && !m.black ? ' last-move' : '');
    wMove.textContent = m.white || '';
    row.appendChild(wMove);

    const bMove = document.createElement('span');
    bMove.className = 'move-black' + (i === moveHistory.length - 1 && m.black ? ' last-move' : '');
    bMove.textContent = m.black || '';
    row.appendChild(bMove);

    el.appendChild(row);
  }

  el.scrollTop = el.scrollHeight;
}

function updateAllUI() {
  if (!gameState) return;

  updatePlayerBars();
  renderMoveList();

  const isMyTurn = gameState.turn === myColor;
  const turnText = gameState.turn === WHITE ? 'White' : 'Black';

  if (gameState.gameOver) {
    if (gameState.winner) {
      const winText = gameState.winner === myColor ? 'You win!' : 'You lose!';
      const colorText = gameState.winner === WHITE ? 'White' : 'Black';
      setStatus(`Checkmate ‚Äî ${colorText} wins! ${myColor ? winText : ''}`, 'win');
    } else {
      setStatus('Stalemate ‚Äî Draw', '');
    }
  } else if (gameState.promotionPending) {
    if (gameState.promotionPending.color === myColor) {
      setStatus('Choose a promotion piece', '');
    } else {
      setStatus('Opponent choosing promotion‚Ä¶', '');
    }
  } else if (isMyTurn) {
    const lastLog = gameState.log?.length > 0 ? gameState.log[gameState.log.length - 1] : '';
    if (lastLog.includes('CHECK')) {
      setStatus('You\'re in check!', 'check');
    } else {
      setStatus('Your turn', '');
    }
  } else {
    const lastLog = gameState.log?.length > 0 ? gameState.log[gameState.log.length - 1] : '';
    if (isBotGame) {
      if (lastLog.includes('CHECK')) {
        setStatus('Computer is in check', 'check');
      } else {
        setStatus('Computer is thinking‚Ä¶', '');
      }
    } else {
      if (lastLog.includes('CHECK')) {
        setStatus(`${turnText} is in check`, 'check');
      } else {
        setStatus(`${turnText} to move`, '');
      }
    }
  }
}

// ============ RESPONSIVE ============
function resizeCanvas() {
  const isMobile = window.innerWidth <= 768;
  const isLandscape = window.innerWidth > window.innerHeight;
  let maxWidth;
  if (isMobile) {
    if (isLandscape) {
      maxWidth = Math.min(640, Math.floor(window.innerHeight * 0.88));
    } else {
      // Portrait: full width minus small margin, but also account for player bars
      maxWidth = Math.min(640, window.innerWidth - 4);
    }
  } else {
    maxWidth = Math.min(640, window.innerWidth - 300);
  }
  canvas.style.width = maxWidth + 'px';
  canvas.style.height = maxWidth + 'px';
}
window.addEventListener('resize', resizeCanvas);
window.addEventListener('orientationchange', () => setTimeout(resizeCanvas, 100));

// ============ INIT ============
document.getElementById('join-code').addEventListener('keydown', (e) => {
  if (e.key === 'Enter') joinRoom();
});

loadPieceImages(() => {
  if (gameState) drawBoard();
});
connect();
resizeCanvas();

// Dismiss overlays on click outside
document.getElementById('learn-overlay').addEventListener('click', (e) => {
  if (e.target === document.getElementById('learn-overlay')) closeLearnOverlay();
});
document.getElementById('tutorial-overlay').addEventListener('click', (e) => {
  if (e.target === document.getElementById('tutorial-overlay')) closeTutorial();
});
document.getElementById('duel-overlay').addEventListener('click', (e) => {
  if (e.target === document.getElementById('duel-overlay')) {
    document.getElementById('duel-overlay').classList.remove('active');
  }
});
</script>
</body>
</html>
